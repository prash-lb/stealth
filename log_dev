commit 7ac8e34cd6d374c4539eeff5b11d4d952abbe175
Author: Massiouane Maibeche <massiouane.maibeche@etud-upem.fr>
Date:   Thu Jan 12 17:04:07 2023 +0100

    Gardien et detec + timer O.K, menu O.K

diff --git a/bin/exe b/bin/exe
index a5e855f..e074baf 100755
Binary files a/bin/exe and b/bin/exe differ
diff --git a/include/Collision.h b/include/Collision.h
index a1894ab..68b3391 100644
--- a/include/Collision.h
+++ b/include/Collision.h
@@ -13,7 +13,8 @@ int est_dans_zone_objet(Position *joueur, Position_obj *objet);
 /*int est_dans_tuile(Joueur const *j, Tuile const *t);*/
 
 
-int gardien_detecte_joueur(Gardien *g);
+int gardien_detecte_joueur(Plateau *p);
+int gardien_detecte_relique(Plateau *plateau, double *sec);
 
 /*Fonction qui calcule et renvoie la distance entre l'agent (Joueur/Gardien)
 et le prochain mur par rapport aux coord actuelles*/
diff --git a/include/Gardien.h b/include/Gardien.h
index 0e8e623..2d1bd6a 100644
--- a/include/Gardien.h
+++ b/include/Gardien.h
@@ -3,6 +3,7 @@
 
 #define NORMAL 4
 #define PANIQUE 6
+#define TEMPS_PANIQUE 30
 
 #include "Deplacement.h"
 
@@ -25,6 +26,7 @@ typedef struct gardien {
     Direction direction;
     Position pos;
     double/*float*/ vitesse;
+    double chrono_panique;
 }Gardien;
 
 
diff --git a/include/Gestion_terrain.h b/include/Gestion_terrain.h
index 5c91e7a..af0aa63 100644
--- a/include/Gestion_terrain.h
+++ b/include/Gestion_terrain.h
@@ -11,11 +11,8 @@ void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_s
 void deplacement_gardien(Plateau *plateau);
 /*faire en sorte de recevoir les 2 gardiens qui veulent se rentrer dedans et les renvoyant dans des direction differente*/
 void interaction_gardien_gardien(Plateau *p);
-<<<<<<< HEAD
 void retour_mana_vers_tuile(Plateau *plateau);
-=======
-
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
+void sortie_du_mode_panique(Plateau *plateau);
 /*retourne 1 si le joueur possede les 3 reliques et qu'il se trouve dans ses coord initiale, ou 0 sinon.*/
 int fin_de_jeu(Joueur const *j);
 
diff --git a/include/Menu.h b/include/Menu.h
new file mode 100644
index 0000000..e3d2318
--- /dev/null
+++ b/include/Menu.h
@@ -0,0 +1,36 @@
+#ifndef __MENU__
+#define __MENU__
+
+#define NB_CASE_HAUTEUR 60
+#define NB_CASE_LARGEUR 45
+#define HAUTEUR_FENETRE LONGUEUR_FENETRE
+#define DIFFERENCE_HAUTEUR HAUTEUR_FENETRE / NB_CASE_HAUTEUR
+#define DIFFERENCE_LARGEUR LARGEUR_FENETRE / NB_CASE_LARGEUR
+#define DELAI_ATTENTE 5
+#define LANCE_JEU 3
+#define OPTION_JEU 2
+#define LOOSE 1
+#define WIN 2
+#include "Moteur_graphique.h"
+
+typedef enum {
+    MENU,
+    JEU,
+    OPTION
+}Menu;
+
+typedef enum {
+    RETOUR,
+    AUTRE
+}Retour;
+
+
+void fabrique_case_menu(char *nom_case, int taille_interlinge, int type_case);
+void fabrique_case_retour(char *nom_case, int taille_interlinge, int largeur);
+void affiche_case_menu(char *nom_case_1, char *nom_case_2, int taille_interlinge, int type_case_1, int type_case_2);
+void affiche_option(char *nom_case_1, char *nom_case_2, int taille_interlinge, int type_case_1, int type_case_2);
+void affiche_menu();
+void ecran_fin_de_jeu(int *fin_de_jeu, double *s, double *ms, int *mana);
+
+
+#endif
diff --git a/include/Moteur_de_jeu.h b/include/Moteur_de_jeu.h
index 0624ed1..77d114f 100644
--- a/include/Moteur_de_jeu.h
+++ b/include/Moteur_de_jeu.h
@@ -13,6 +13,7 @@
 #define NB_GARDIEN 5
 #define NB_TUILE 20
 #define QUANTITE_MANA_TUILE 60
+#define LIMITE_NB_PANIQUE 3
 #define minside 9
 
 typedef enum element_de_jeu{
@@ -32,10 +33,7 @@ typedef struct tuile{
 }Tuile;
 
 typedef struct plateau{
-<<<<<<< HEAD
     int cpt_mana;
-=======
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
     int plateau[LARGEUR_PLATEAU][LONGEUR_PLATEAU];
     Joueur joueur;
     Gardien gardien[NB_GARDIEN];
diff --git a/include/Moteur_graphique.h b/include/Moteur_graphique.h
index 8196672..486714f 100644
--- a/include/Moteur_graphique.h
+++ b/include/Moteur_graphique.h
@@ -2,9 +2,12 @@
 #define __MOTEUR_GRAPHIQUE__
 
 #include "Gestion_terrain.h"
+#include <string.h>
+#include <stdlib.h>
 #define TAILLE_CASE 15
 #define LONGUEUR_FENETRE (LONGEUR_PLATEAU * TAILLE_CASE)
 #define LARGEUR_FENETRE (LARGEUR_PLATEAU * TAILLE_CASE)
+#define EXTENSION 100
 
 /*
 0 : case vide
@@ -14,6 +17,6 @@
 4 : joueur
 */
 
-void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur);
+void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur, double *sec);
 
 #endif
diff --git a/loose.jpg b/loose.jpg
new file mode 100644
index 0000000..186fe45
Binary files /dev/null and b/loose.jpg differ
diff --git a/makefile b/makefile
index e863f05..08c1b50 100644
--- a/makefile
+++ b/makefile
@@ -2,7 +2,7 @@ CC = gcc
 CFLAGS = -ansi -Wall -pedantic
 LDFLAGS =-lm -lrt
 MLV= -lMLV
-OBJ = obj/main.o obj/Collision.o obj/Gardien.o obj/Gestion_terrain.o obj/Joueur.o obj/Moteur_de_jeu.o obj/Moteur_graphique.o obj/Relique.o obj/Deplacement.o
+OBJ = obj/main.o obj/Collision.o obj/Gardien.o obj/Gestion_terrain.o obj/Joueur.o obj/Moteur_de_jeu.o obj/Moteur_graphique.o obj/Relique.o obj/Deplacement.o obj/Menu.o
 DIR_SRC = src
 DIR_OBJ = obj
 DIR_HEADER = include
@@ -14,7 +14,7 @@ all: $(DIR_BIN)/$(TARGET)
 $(DIR_BIN)/$(TARGET): $(OBJ)
 	$(CC) $(CFLAGS) -o $@  $^ $(LDFLAGS) $(MLV)
 
-$(DIR_OBJ)/main.o: $(DIR_SRC)/main.c $(DIR_HEADER)/Gestion_terrain.h $(DIR_HEADER)/Moteur_graphique.h
+$(DIR_OBJ)/main.o: $(DIR_SRC)/main.c $(DIR_HEADER)/Menu.h $(DIR_HEADER)/Moteur_graphique.h
 	$(CC) -c $< -o $(DIR_OBJ)/main.o $(CFLAGS)
 
 $(DIR_OBJ)/Deplacement.o: $(DIR_SRC)/Deplacement.c $(DIR_HEADER)/Deplacement.h
@@ -41,6 +41,9 @@ $(DIR_OBJ)/Collision.o: $(DIR_SRC)/Collision.c $(DIR_HEADER)/Collision.h $(DIR_H
 $(DIR_OBJ)/Gestion_terrain.o: $(DIR_SRC)/Gestion_terrain.c $(DIR_HEADER)/Gestion_terrain.h $(DIR_HEADER)/Collision.h
 	$(CC) -c $< -o $(DIR_OBJ)/Gestion_terrain.o $(CFLAGS)
 
+$(DIR_OBJ)/Menu.o: $(DIR_SRC)/Menu.c $(DIR_HEADER)/Menu.h $(DIR_HEADER)/Moteur_graphique.h
+	$(CC) -c $< -o $(DIR_OBJ)/Menu.o $(CFLAGS)
+
 #Au cas ou on ajouterrai d'autre module
 #$(DIR_OBJ)/arboresence.o: $(DIR_SRC)/.c $(DIR_HEADER)/.h
 #	$(CC) -c $< -o $(DIR_OBJ)/.o $(CFLAGS)
diff --git a/obj/.o b/obj/.o
new file mode 100644
index 0000000..2525587
Binary files /dev/null and b/obj/.o differ
diff --git a/obj/Collision.o b/obj/Collision.o
index 8ca6e1b..250cc7a 100644
Binary files a/obj/Collision.o and b/obj/Collision.o differ
diff --git a/obj/Gardien.o b/obj/Gardien.o
index 9968ddd..066ae2c 100644
Binary files a/obj/Gardien.o and b/obj/Gardien.o differ
diff --git a/obj/Gestion_terrain.o b/obj/Gestion_terrain.o
index 4a061ec..eabd207 100644
Binary files a/obj/Gestion_terrain.o and b/obj/Gestion_terrain.o differ
diff --git a/obj/Menu.o b/obj/Menu.o
new file mode 100644
index 0000000..db7a4df
Binary files /dev/null and b/obj/Menu.o differ
diff --git a/obj/Moteur_de_jeu.o b/obj/Moteur_de_jeu.o
index cd93005..7cc5fa9 100644
Binary files a/obj/Moteur_de_jeu.o and b/obj/Moteur_de_jeu.o differ
diff --git a/obj/Moteur_graphique.o b/obj/Moteur_graphique.o
index 5822abb..83b4523 100644
Binary files a/obj/Moteur_graphique.o and b/obj/Moteur_graphique.o differ
diff --git a/obj/main.o b/obj/main.o
index 1071839..5c505a0 100644
Binary files a/obj/main.o and b/obj/main.o differ
diff --git a/src/Collision.c b/src/Collision.c
index fa9bc8f..f413bbc 100644
--- a/src/Collision.c
+++ b/src/Collision.c
@@ -41,9 +41,88 @@ int est_dans_tuile(Joueur const *joueur, Tuile const *tuile){
     return ((int)(joueur->pos.x) == tuile->pos.x && (int)(joueur->pos.y) == tuile->pos.y) ? 1 : 0;
 }*/
 
+/*calcule la distance euclidienne entre le joueur et le gardien*/
+static int rayon_detection_gardien(Position *joueur, Position *gardien){
+    /*pow(coord1[0] - coord2[0], 2) + pow(coord1[1] - coord2[1], 2)*/
+    return sqrt((joueur->x - gardien->x)*(joueur->x - gardien->x) + (joueur->y - gardien->y)*(joueur->y - gardien->y));
+}
+
+static int mur(Plateau *plateau, int *num_gardien){
+    int a;
+    double Pa, Ya;
+    /*côté de detection à gauche*/
+    for(a = (int)plateau->joueur.pos.x + 1; a < (int)plateau->gardien[*num_gardien].pos.x; ++a){
+        Pa = (a - plateau->gardien[*num_gardien].pos.x) / (plateau->joueur.pos.x - plateau->gardien[*num_gardien].pos.x);
+        Ya = (Pa * plateau->joueur.pos.y) + (1 - Pa) * plateau->gardien[*num_gardien].pos.y;
+        if(plateau->plateau[(int)Ya][a] == MUR){
+            return 1;
+        }
+    }
+    /*haut*/
+    for(a = (int)plateau->joueur.pos.y + 1; a < (int)plateau->gardien[*num_gardien].pos.y; ++a){
+        Pa = (a - plateau->gardien[*num_gardien].pos.y) / (plateau->joueur.pos.y - plateau->gardien[*num_gardien].pos.y);
+        Ya = (Pa * plateau->joueur.pos.x) + (1 - Pa) * plateau->gardien[*num_gardien].pos.x;
+        if(plateau->plateau[a][(int)Ya] == MUR){
+            return 1;
+        }
+    }
+    /*bas*/
+    for(a = (int)plateau->gardien[*num_gardien].pos.y + 1; a < (int)plateau->joueur.pos.y; ++a){
+        Pa = (a - plateau->joueur.pos.y) / (plateau->gardien[*num_gardien].pos.y - plateau->joueur.pos.y);
+        Ya = Pa * plateau->gardien[*num_gardien].pos.x + (1 - Pa) * plateau->joueur.pos.x;
+        if(plateau->plateau[a][(int)Ya] == MUR){
+            return 1;
+        }
+    }
+    /*côté de detection à droite*/
+    for(a = (int)plateau->gardien[*num_gardien].pos.x + 1; a < (int)plateau->joueur.pos.x; ++a){
+        Pa = (a - plateau->joueur.pos.x) / (plateau->gardien[*num_gardien].pos.x - plateau->joueur.pos.x);
+        Ya = Pa * plateau->gardien[*num_gardien].pos.y + (1 - Pa) * plateau->joueur.pos.y;
+        if(plateau->plateau[(int)Ya][a] == MUR){
+            return 1;
+        }
+    }
+    return 0;
+}
 
+/*renvoie 0 si le joueur est detecté et 1 sinon*/
+int gardien_detecte_joueur(Plateau *plateau){
+    int i;
+    for(i = 0; i < NB_GARDIEN; ++i){
+        /*coté gauche du gardien*/
+        if(rayon_detection_gardien(&(plateau->joueur.pos), &(plateau->gardien[i].pos)) <= plateau->gardien[i].distance_detection &&
+            mur(plateau, &i) == 0 && plateau->joueur.mode != MODE_INVISIBLE){
+            printf("joueur detecté \n");
+            return 1;
+        }
+    }
+    return 0;
+}
+
+
+static int rayon_detection_gardien_tuile(Position_obj *relique, Position *gardien){
+    /*pow(coord1[0] - coord2[0], 2) + pow(coord1[1] - coord2[1], 2)*/
+    return sqrt((relique->x - gardien->x) * (relique->x - gardien->x) +
+        (relique->y - gardien->y) * (relique->y - gardien->y));
+}
 
-int gardien_detecte_joueur(Gardien *g){
+int gardien_detecte_relique(Plateau *plateau, double *sec){
+    int i, j;
+    for(i = 0; i < NB_GARDIEN; ++i){
+        for(j = 0; j < NB_RELIQUE; ++j){
+            if(rayon_detection_gardien_tuile(&(plateau->relique[j].pos), &(plateau->gardien[i].pos)) <= plateau->gardien[i].distance_detection &&
+                plateau->relique[j].etat == RECUPERER && plateau->gardien[i].cpt_panique <= LIMITE_NB_PANIQUE && plateau->gardien[i].alerte == MODE_NORMAL){
+                    config_gardien_mode_panique(&(plateau->gardien[i]));
+                    plateau->gardien[i].cpt_panique++;
+                    plateau->gardien[i].chrono_panique = *sec + TEMPS_PANIQUE;
+                    /*printf("LA RELIQUE A DISPARU LA! -> \n");*/
+            }
+            else if(plateau->gardien[i].chrono_panique <= *sec && plateau->gardien[i].alerte == MODE_PANIQUE){
+                config_gardien_mode_normal(&(plateau->gardien[i]));
+            }
+            /*printf("chrono_gardien = %.1f et sec = %.1f\n", plateau->gardien[i].chrono_panique, *sec);*/
+        }
+    }
     return 0;
 }
 
diff --git a/src/Gardien.c b/src/Gardien.c
index 18db4b5..c278933 100644
--- a/src/Gardien.c
+++ b/src/Gardien.c
@@ -42,6 +42,7 @@ void config_gardien_mode_normal(Gardien *g){
     g->alerte = MODE_NORMAL;
     g->detecte = JOUEUR_NON_DETECTE;
     g->distance_detection = NORMAL;
+    g->chrono_panique = 0;
     change_vitesse_gardien(&(g->alerte), &(g->vitesse));
     change_direction_(&(g->direction));
 }
@@ -51,6 +52,7 @@ void config_gardien_mode_panique(Gardien *g){
     g->alerte = MODE_PANIQUE;
     g->detecte = JOUEUR_NON_DETECTE;
     g->distance_detection = PANIQUE;
+    g->chrono_panique = 0;
     change_vitesse_gardien(&(g->alerte), &(g->vitesse));
     change_direction_(&(g->direction));
 }
diff --git a/src/Gestion_terrain.c b/src/Gestion_terrain.c
index 3d0818b..6152482 100644
--- a/src/Gestion_terrain.c
+++ b/src/Gestion_terrain.c
@@ -73,7 +73,6 @@ void interaction_gardien_gardien(Plateau *plateau){
 }
 
 
-<<<<<<< HEAD
 static void gestion_mode_joueur(Joueur *joueur, MLV_Keyboard_modifier *mod, int *cpt){
     assert(NULL != joueur);
 
@@ -88,33 +87,6 @@ static void gestion_mode_joueur(Joueur *joueur, MLV_Keyboard_modifier *mod, int
         joueur->mode = MODE_INVISIBLE;
         joueur->mana -= 1;
         *cpt += 1;
-=======
-static void gestion_mode_acceleration_joueur(Joueur *joueur, MLV_Keyboard_modifier *mod){
-    assert(NULL != joueur);
-
-    if(MLV_shift_key_was_pressed(*mod) && joueur->mana > 2){
-        printf("Tu as pressé la touche shift\n");
-        joueur->mode = MODE_ACCELERE;
-        joueur->mana -= 2;
-    }
-    else if(MLV_get_keyboard_state(MLV_KEYBOARD_SPACE) == MLV_PRESSED/*MLV_shift_key_was_pressed(*mod)*/ && joueur->mana > 1){
-        printf("Tu as pressé la touche espace\n");
-        joueur->mode = MODE_INVISIBLE;
-        joueur->mana -= 1;
-    }
-    else{
-        joueur->mode = MODE_NORMAL;
-    }
-}
-
-static void gestion_mode_invisible_joueur(Joueur *joueur){
-    assert(NULL != joueur);
-
-    if(MLV_get_keyboard_state(MLV_KEYBOARD_SPACE) == MLV_PRESSED/*MLV_shift_key_was_pressed(*mod)*/ && joueur->mana > 1){
-        printf("Tu as pressé la touche espace\n");
-        joueur->mode = MODE_INVISIBLE;
-        joueur->mana -= 1;
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
     }
     else{
         joueur->mode = MODE_NORMAL;
@@ -123,74 +95,33 @@ static void gestion_mode_invisible_joueur(Joueur *joueur){
 
 /*interaction_joueur_mur ==> a gerer dans les deplacment du joueur*/
 void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_state *state, MLV_Keyboard_modifier *mod){
-<<<<<<< HEAD
 
     gestion_mode_joueur(&(plateau->joueur), mod, &(plateau->cpt_mana));
     if(*sym == MLV_KEYBOARD_z && *state == MLV_PRESSED){
         plateau->joueur.direction = HAUT;
-=======
-    
-    /*gestion_mode_invisible_joueur(&(plateau->joueur));*/
-    gestion_mode_acceleration_joueur(&(plateau->joueur), mod);
-    switch(plateau->joueur.mode){
-        case MODE_NORMAL: printf("MODE_NORMAL\n"); break;
-        case MODE_ACCELERE: printf("MODE_ACCELERE\n"); break;
-        case MODE_INVISIBLE: printf("MODE_INVISIBLE\n"); break;
-        default:break;
-    }
-    if(*sym == MLV_KEYBOARD_z && *state == MLV_PRESSED){
-        plateau->joueur.direction = HAUT;/*
-        if(MLV_shift_key_was_pressed(*mod)){
-            printf("Tu as presser la touche shift-haut\n");
-        }*/
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
         if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
             augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
             plateau->joueur.pos.y -= plateau->joueur.vitesse; /*printf("P-HAUT ");*/
         }
     }
     else if(*sym == MLV_KEYBOARD_s && *state == MLV_PRESSED){
-<<<<<<< HEAD
         plateau->joueur.direction = BAS;
         if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
-=======
-        plateau->joueur.direction = BAS;/*
-        if(MLV_shift_key_was_pressed(*mod)){
-            printf("Tu as presser la touche shift-bas\n");
-        }*/
-        if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
             augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
             plateau->joueur.pos.y += plateau->joueur.vitesse; /*printf("P-BAS ");*/
         }
 
     }
     else if(*sym == MLV_KEYBOARD_q && *state == MLV_PRESSED){
-<<<<<<< HEAD
         plateau->joueur.direction = GAUCHE;
         if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
-=======
-        plateau->joueur.direction = GAUCHE;/*
-        if(MLV_shift_key_was_pressed(*mod)){
-            printf("Tu as presser la touche shift-gauche\n");
-        }*/
-        if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
             augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
             plateau->joueur.pos.x -= plateau->joueur.vitesse; /*printf("P-GAUCHE ");*/
         }
     }
     else if(*sym == MLV_KEYBOARD_d && *state == MLV_PRESSED){
-<<<<<<< HEAD
         plateau->joueur.direction = DROITE;
         if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
-=======
-        plateau->joueur.direction = DROITE;/*
-        if(MLV_shift_key_was_pressed(*mod)){
-            printf("Tu as presser la touche shift-droite\n");
-        }*/
-        if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
             augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
             plateau->joueur.pos.x += plateau->joueur.vitesse; /*printf("P-DROITE ");*/
         }
@@ -198,7 +129,10 @@ void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_s
     else{
         plateau->joueur.vitesse = VITESSE_NULLE;
     }
-<<<<<<< HEAD
+}
+
+void sortie_du_mode_panique(Plateau *plateau){
+    return ;
 }
 
 void retour_mana_vers_tuile(Plateau *plateau){
@@ -229,21 +163,6 @@ static void effectue_deplacement_gardien(Gardien *g){
     }
 }
 
-=======
-}
-
-
-static void effectue_deplacement_gardien(Gardien *g){
-    switch(g->direction){
-        case HAUT : g->pos.y -= g->vitesse; break;
-        case BAS : g->pos.y += g->vitesse; break;
-        case GAUCHE : g->pos.x -= g->vitesse; break;
-        case DROITE : g->pos.x += g->vitesse; break;
-        default : break;
-    }
-}
-
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
 static void direction_opposer(Direction *d){
     switch(*d){
         case HAUT : *d = BAS; break;
diff --git a/src/Menu.c b/src/Menu.c
new file mode 100644
index 0000000..94e1fe5
--- /dev/null
+++ b/src/Menu.c
@@ -0,0 +1,130 @@
+#include "../include/Menu.h"
+
+
+/*Fonction pour afficher une case du menu*/
+void fabrique_case_menu(char *nom_case, int taille_interlinge, int type_case){
+    MLV_draw_adapted_text_box(
+        ((HAUTEUR_FENETRE - strlen(nom_case) * DIFFERENCE_HAUTEUR) + EXTENSION) / 2,
+        LARGEUR_FENETRE / type_case,
+        nom_case,
+        taille_interlinge,
+        MLV_COLOR_RED, MLV_COLOR_GREEN, MLV_COLOR_BLACK,
+        MLV_TEXT_CENTER
+    );
+}
+
+void fabrique_case_retour(char *nom_case, int taille_interlinge, int largeur){
+    MLV_draw_adapted_text_box(
+        ((HAUTEUR_FENETRE - strlen(nom_case) * DIFFERENCE_HAUTEUR) + EXTENSION) / 2,
+        largeur,
+        nom_case,
+        taille_interlinge,
+        MLV_COLOR_RED, MLV_COLOR_GREEN, MLV_COLOR_BLACK,
+        MLV_TEXT_CENTER
+    );
+}
+
+void affiche_case_menu(char *nom_case_1, char *nom_case_2, int taille_interlinge, int type_case_1, int type_case_2){
+    MLV_clear_window(MLV_COLOR_BLACK);
+    fabrique_case_menu(nom_case_1, taille_interlinge, type_case_1);
+    fabrique_case_menu(nom_case_2, taille_interlinge, type_case_2);
+    MLV_actualise_window();
+
+}
+
+/*temporaire*/
+
+
+void affiche_option(char *nom_case_1, char *nom_case_2, int taille_interlinge, int type_case_1, int type_case_2){
+    char *lance_jeu = "OPTION";
+    char *retour = "RETOUR";
+    int x = ((HAUTEUR_FENETRE - strlen(retour) * DIFFERENCE_HAUTEUR) + EXTENSION) / 2;
+    int y = LARGEUR_FENETRE;
+    int n = 0, clic_x, clic_y;
+    Retour etat = AUTRE;
+    /*Action*/
+    MLV_clear_window(MLV_COLOR_BLACK);
+    fabrique_case_menu(lance_jeu, taille_interlinge, LARGEUR_FENETRE);
+    fabrique_case_retour(retour, taille_interlinge, LARGEUR_FENETRE - (taille_interlinge * 3 + 5));
+    MLV_actualise_window();
+    while(n == 0){
+        MLV_wait_mouse(&clic_x, &clic_y);
+        if(clic_x <= (x + strlen(retour) * (taille_interlinge + 3)) && clic_x >= x && clic_y <= y && clic_y >= (y - (4 * taille_interlinge) + 5)){
+            etat = RETOUR;
+            n = 1;
+        }
+        switch(etat){
+            case RETOUR : affiche_case_menu(nom_case_1, nom_case_2, taille_interlinge, type_case_1, type_case_2); break;
+            default : break;
+        }
+    }
+}
+
+/*fct qui affiche le menu*/
+void affiche_menu(){
+    char lance_jeu[15];
+    char option[15];
+    int taille_interlinge;
+    int clic_x, clic_y, x, y_jeu, y_opt;
+    int n;
+    Menu etat;
+
+    n = 0;
+    taille_interlinge = 10;
+    etat = MENU;
+    sprintf(lance_jeu, "Lancer Le Jeu");
+    sprintf(option, "Option de Jeu");
+
+    x = ((HAUTEUR_FENETRE - strlen(lance_jeu) * DIFFERENCE_HAUTEUR) + EXTENSION) / 2;
+    y_jeu = LARGEUR_FENETRE / LANCE_JEU;
+    y_opt = LARGEUR_FENETRE / OPTION_JEU;
+    /*Action*/
+    /*affichage des cases pour lance et option */
+    affiche_case_menu(lance_jeu, option, taille_interlinge, LANCE_JEU, OPTION_JEU);
+    MLV_actualise_window();
+    /*Attente_clic etc pour option et lance jeu*/
+    while(n == 0){
+        etat = MENU;
+        MLV_wait_mouse(&clic_x, &clic_y);
+        if(clic_x <= (x + taille_interlinge*(taille_interlinge + 1)) && clic_x >= x && clic_y >= y_jeu && clic_y <= (y_jeu + (3 * taille_interlinge) + 5)){
+            etat = JEU;
+            n = 1;
+        }
+        else if(clic_x <= (x + taille_interlinge*(taille_interlinge + 1)) && clic_x >= x && clic_y >= y_opt && clic_y <= (y_opt + (3 * taille_interlinge) + 5)){
+            etat = OPTION;
+        }
+        switch(etat){
+            case JEU : break;
+            case OPTION : affiche_option(lance_jeu, option, taille_interlinge, LANCE_JEU, OPTION_JEU); break;
+            default : break;
+        }
+    }
+    MLV_actualise_window();
+}
+
+static void ecran_gagnant(double *s, double *ms, int *mana){
+    char win[100];
+    sprintf(win, "You win this game, your time is %.2fs and you use %d mana", *s + *ms, *mana);
+    MLV_clear_window(MLV_COLOR_BLACK);
+    MLV_draw_text((LONGUEUR_FENETRE - EXTENSION * 3) / 2,(LARGEUR_FENETRE) / 2, win, MLV_COLOR_ORANGE);
+    MLV_actualise_window();
+    sleep(DELAI_ATTENTE);
+}
+
+static void ecran_perdant(){
+    MLV_Image *pic;
+    pic = MLV_load_image("loose.jpg");
+    MLV_clear_window(MLV_COLOR_BLACK);
+    MLV_draw_image(pic, 0, EXTENSION);
+    MLV_actualise_window();
+    sleep(DELAI_ATTENTE);
+    MLV_free_image(pic);
+}
+
+void ecran_fin_de_jeu(int *fin_de_jeu, double *s, double *ms, int *mana){
+    switch(*fin_de_jeu){
+        case LOOSE : ecran_perdant(); break;
+        case WIN : ecran_gagnant(s, ms, mana); break;
+        default : break;
+    }
+}
diff --git a/src/Moteur_de_jeu.c b/src/Moteur_de_jeu.c
index 25a3f86..bca5511 100644
--- a/src/Moteur_de_jeu.c
+++ b/src/Moteur_de_jeu.c
@@ -449,10 +449,7 @@ static void init_objects_in_map(Plateau *game){
 
     initialise_joueur(&(game->joueur));
     printf(" x = %.0f \n", game->joueur.pos.x);
-<<<<<<< HEAD
     game->cpt_mana = 0;
-=======
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
     init_Gardien(game);
     init_Relique(game);
     init_tuile(game);
diff --git a/src/Moteur_graphique.c b/src/Moteur_graphique.c
index 7bba30b..3677cdf 100644
--- a/src/Moteur_graphique.c
+++ b/src/Moteur_graphique.c
@@ -9,6 +9,25 @@ affichage du menu
 FRAME --> a reglé 1/60
 */
 
+static void fenetre_temps(double *sec){
+    char *tmp;
+    tmp = (char*)malloc(sizeof(char) * 50);
+
+    sprintf(tmp, "%.0f", *sec);
+    strcat(tmp, " s");
+    MLV_draw_text(LONGUEUR_FENETRE + TAILLE_CASE, 10, "TEMPS", MLV_COLOR_WHITE);
+    MLV_draw_text(LONGUEUR_FENETRE + TAILLE_CASE, 25, tmp, MLV_COLOR_WHITE);
+    free(tmp);
+}
+
+static void mana_du_joueur(const int *mana){
+    char *tmp;
+    tmp = (char*)malloc(sizeof(char) * 50);
+    sprintf(tmp, "Mana : %.d", *mana);
+    MLV_draw_text(LONGUEUR_FENETRE + TAILLE_CASE, 50, tmp, MLV_COLOR_WHITE);
+    free(tmp);
+}
+
 static void dessine_quadrillage(int longueur, int largeur){
     int i;
     for(i = 0; i <= largeur; i += TAILLE_CASE){
@@ -109,8 +128,7 @@ static void dessine_joueur(Joueur const *joueur){
 }
 
 
-
-void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur){
+void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur, double *sec){
     int i, j, case_x, case_y;
     MLV_clear_window(MLV_COLOR_GREY40);
     dessine_quadrillage(longueur * TAILLE_CASE, largeur * TAILLE_CASE);
@@ -130,5 +148,7 @@ void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur){
     dessine_gardien(p);
     dessine_tuile(p);
     dessine_relique(p);
+    fenetre_temps(sec);
+    mana_du_joueur(&(p->joueur.mana));
     MLV_actualise_window();
 }
diff --git a/src/main.c b/src/main.c
index 84f741b..c770854 100644
--- a/src/main.c
+++ b/src/main.c
@@ -2,8 +2,7 @@
 #define _POSIX_C_SOURCE 1999309L
 /*Uniquement car on utilise clock_gettime, car ce ,'est pas ansi C89'*/
 
-#include "../include/Gestion_terrain.h"
-#include "../include/Moteur_graphique.h"
+#include "../include/Menu.h"
 #include <time.h>
 
 static void aff_plat(Plateau *plat){
@@ -24,34 +23,38 @@ static void aff_plat(Plateau *plat){
 }
 
 
-
 int main(int argc, const char * const argv[]){
     int fin_de_partie;
     Plateau plateau;
     struct timespec new_time, end_time;
     double frametime, extratime;
+    double sec, ms;
     struct timespec start, end;
     MLV_Keyboard_modifier mod;
     MLV_Keyboard_button sym;
     MLV_Button_state state;
     MLV_Event event;
     frametime = extratime = 0.0;
-    fin_de_partie = 1;
+    fin_de_partie = 0;
     mod = MLV_KEYBOARD_KMOD_NONE;
     sym = MLV_KEYBOARD_NONE;
     state = MLV_RELEASED;
     event = MLV_NONE;
 
     srand(time(NULL));
-    MLV_create_window("ko", "ka", LONGUEUR_FENETRE, LARGEUR_FENETRE);
+    MLV_create_window("ko", "ka", LONGUEUR_FENETRE + EXTENSION, LARGEUR_FENETRE);
     create_map(&plateau);
     /*aff_plat(&plateau);*/
-
+    affiche_menu();
     clock_gettime(CLOCK_REALTIME, &start);
-    while(fin_de_partie){
+    plateau.joueur.mana = 1000;
+    plateau.joueur.nb_relique = 3;
+    while(fin_de_partie == 0){
         /*CALCUL_DE_TEMPS*/
+        clock_gettime(CLOCK_REALTIME, &end);
         clock_gettime(CLOCK_REALTIME, &end_time);
-        dessine_plateau_graphique(&plateau, LONGEUR_PLATEAU, LARGEUR_PLATEAU);
+        sec = (double) (end.tv_sec - start.tv_sec);
+        dessine_plateau_graphique(&plateau, LONGEUR_PLATEAU, LARGEUR_PLATEAU, &sec);
         event = MLV_get_event(&sym, &mod, NULL, NULL, NULL, NULL, NULL, NULL, &state);
         /*printf("state %d: \n", state);*/
         deplacement_joueur(&plateau, &sym, &state, &mod);
@@ -64,15 +67,13 @@ int main(int argc, const char * const argv[]){
             }
         }
         /*Mecanisme de jeu et tt*/
+        fin_de_partie = gardien_detecte_joueur(&plateau);
         interaction_joueur_relique(&plateau);
         interaction_joueur_tuile(&plateau);
-<<<<<<< HEAD
         interaction_gardien_gardien(&plateau);
         retour_mana_vers_tuile(&plateau);
+        gardien_detecte_relique(&plateau, &sec);
 
-=======
-        interaction_gardien_gardien(&(plateau));
->>>>>>> fa73ccf449c159cfa678bced0a1b5cfad4524213
         /*framerate*/
         clock_gettime(CLOCK_REALTIME, &new_time);
         frametime = new_time.tv_sec - end_time.tv_sec;
@@ -84,12 +85,15 @@ int main(int argc, const char * const argv[]){
         }
         /*fin de partie*/
         if(fin_de_jeu(&(plateau.joueur))){
-            fin_de_partie = 0;
+            fin_de_partie = WIN;
         }
     }
     clock_gettime(CLOCK_REALTIME, &end);
+    sec = (double) (end.tv_sec - start.tv_sec);
+    ms = (double) ((end.tv_nsec - start.tv_nsec) / 1.0E9);
+    ecran_fin_de_jeu(&fin_de_partie, &sec, &ms, &(plateau.joueur.mana));
     /*Chrono rapide du joueur - a ameliorer eventuellement ==> */
-    printf("Durée de la partie = %.2fs\n",(double) ((end.tv_sec - start.tv_sec) + ((end.tv_nsec - start.tv_nsec) / 1.0E9)));
+    printf("Durée de la partie = %.2fs\n", sec + ms);
     printf("plateau taille = %d\n", (int)sizeof(plateau));
     printf("joeur taille = %d\n", (int)sizeof(plateau.joueur));
     printf("gard taille = %d\n", (int)sizeof(plateau.gardien));

commit 0d25cec6f0a7921f3b66f5a738e100d8798b870d
Merge: 043c50c fa73ccf
Author: Massiouane Maibeche <massiouane.maibeche@etud-upem.fr>
Date:   Wed Jan 11 16:16:51 2023 +0100

    gestion objet

commit 043c50c060f1ae3a224c9043aa4c0ee0189a875f
Author: Massiouane Maibeche <massiouane.maibeche@etud-upem.fr>
Date:   Wed Jan 11 16:07:06 2023 +0100

    detection objet revu

diff --git a/bin/exe b/bin/exe
index c15c8cc..a5e855f 100755
Binary files a/bin/exe and b/bin/exe differ
diff --git a/include/Collision.h b/include/Collision.h
index e16dd24..a1894ab 100644
--- a/include/Collision.h
+++ b/include/Collision.h
@@ -1,15 +1,16 @@
 #ifndef __COLLISION__
 #define __COLLISION__
 
-#define MARGE_DISTANCE 0.25
+#define MARGE_DISTANCE 1.00
 #include "Moteur_de_jeu.h"
 
 
+int est_dans_zone_objet(Position *joueur, Position_obj *objet);
 /*renvoie 1 si le joueur est sur un relique ou 0 sinon*/
-int est_dans_relique(Joueur const *j, Relique const *r);
+/*int est_dans_relique(Joueur const *j, Relique const *r);*/
 
 /*renvoie 1 si la pos du joueur est sur la meme pos que la tuile ou 0 sinon.*/
-int est_dans_tuile(Joueur const *j, Tuile const *t);
+/*int est_dans_tuile(Joueur const *j, Tuile const *t);*/
 
 
 int gardien_detecte_joueur(Gardien *g);
diff --git a/include/Deplacement.h b/include/Deplacement.h
index ddcb86e..5b63e6c 100644
--- a/include/Deplacement.h
+++ b/include/Deplacement.h
@@ -1,6 +1,7 @@
 #ifndef __DEPLACEMENT__
 #define __DEPLACEMENT__
 
+#define VITESSE_NULLE 0.0
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
@@ -24,5 +25,4 @@ typedef struct position{
     /*float*/double x, y; /*position 2D*/
 }Position;
 
-void change_direction(Position *p, Direction direction);
 #endif
diff --git a/include/Gardien.h b/include/Gardien.h
index cf21739..0e8e623 100644
--- a/include/Gardien.h
+++ b/include/Gardien.h
@@ -24,11 +24,11 @@ typedef struct gardien {
     int distance_detection;
     Direction direction;
     Position pos;
-    float vitesse;
+    double/*float*/ vitesse;
 }Gardien;
 
 
-void change_vitesse_gardien(Etat_gardien *etat, float *vitesse);
+void change_vitesse_gardien(Etat_gardien *etat, double/*float*/ *vitesse);
 void change_direction_(Direction *d);
 void config_gardien_mode_normal(Gardien *g);
 void config_gardien_mode_panique(Gardien *g);
diff --git a/include/Gestion_terrain.h b/include/Gestion_terrain.h
index 45cc6f7..f68ac30 100644
--- a/include/Gestion_terrain.h
+++ b/include/Gestion_terrain.h
@@ -2,14 +2,16 @@
 #define __GESTION_TERRAIN__
 
 #include "Collision.h"
+#include "MLV/MLV_all.h"
+#include <unistd.h>
 
 int interaction_joueur_relique(Plateau *p);
 int interaction_joueur_tuile(Plateau *p);
-void deplacement_joueur(Plateau *p);
-
+void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_state *state, MLV_Keyboard_modifier *mod);
+void deplacement_gardien(Plateau *plateau);
 /*faire en sorte de recevoir les 2 gardiens qui veulent se rentrer dedans et les renvoyant dans des direction differente*/
-void interaction_gardien_gardien();
-
+void interaction_gardien_gardien(Plateau *p);
+void retour_mana_vers_tuile(Plateau *plateau);
 /*retourne 1 si le joueur possede les 3 reliques et qu'il se trouve dans ses coord initiale, ou 0 sinon.*/
 int fin_de_jeu(Joueur const *j);
 
diff --git a/include/Moteur_de_jeu.h b/include/Moteur_de_jeu.h
index 11a9d4e..1111fc2 100644
--- a/include/Moteur_de_jeu.h
+++ b/include/Moteur_de_jeu.h
@@ -8,20 +8,32 @@
 
 #define LARGEUR_PLATEAU 45
 #define LONGEUR_PLATEAU 60
+#define DISTANCE_MIN_JOUEUR_GARDIEN_OBJ 20
 #define NB_RELIQUE 3
 #define NB_GARDIEN 5
 #define NB_TUILE 20
+#define QUANTITE_MANA_TUILE 60
 #define minside 9
 
+typedef enum element_de_jeu{
+    VIDE,
+    MUR,
+    GARDIEN,
+    RELIQUE,
+    JOUEUR,
+    TUILE
+}Element_de_jeu;
 
-typedef struct {
+
+typedef struct tuile{
     Etat_objet etat;
     Position_obj pos;
     int mana;/*60*/
 }Tuile;
 
-typedef struct {
-    int plateau [LARGEUR_PLATEAU][LONGEUR_PLATEAU];
+typedef struct plateau{
+    int cpt_mana;
+    int plateau[LARGEUR_PLATEAU][LONGEUR_PLATEAU];
     Joueur joueur;
     Gardien gardien[NB_GARDIEN];
     Relique relique[NB_RELIQUE];
diff --git a/makefile b/makefile
index 9ce3380..e863f05 100644
--- a/makefile
+++ b/makefile
@@ -46,4 +46,4 @@ $(DIR_OBJ)/Gestion_terrain.o: $(DIR_SRC)/Gestion_terrain.c $(DIR_HEADER)/Gestion
 #	$(CC) -c $< -o $(DIR_OBJ)/.o $(CFLAGS)
 
 clean:
-	rm -f $(OBJ) $(TARGET)
+	rm -f $(OBJ) $(DIR_BIN)/$(TARGET)
diff --git a/obj/Collision.o b/obj/Collision.o
index 8ce31e0..8ca6e1b 100644
Binary files a/obj/Collision.o and b/obj/Collision.o differ
diff --git a/obj/Deplacement.o b/obj/Deplacement.o
index a69d4dd..af4479c 100644
Binary files a/obj/Deplacement.o and b/obj/Deplacement.o differ
diff --git a/obj/Gardien.o b/obj/Gardien.o
index c3378fc..9968ddd 100644
Binary files a/obj/Gardien.o and b/obj/Gardien.o differ
diff --git a/obj/Gestion_terrain.o b/obj/Gestion_terrain.o
index a5b4263..4a061ec 100644
Binary files a/obj/Gestion_terrain.o and b/obj/Gestion_terrain.o differ
diff --git a/obj/Moteur_de_jeu.o b/obj/Moteur_de_jeu.o
index bef860c..cd93005 100644
Binary files a/obj/Moteur_de_jeu.o and b/obj/Moteur_de_jeu.o differ
diff --git a/obj/Moteur_graphique.o b/obj/Moteur_graphique.o
index 4cd2f3e..5822abb 100644
Binary files a/obj/Moteur_graphique.o and b/obj/Moteur_graphique.o differ
diff --git a/obj/main.o b/obj/main.o
index c09c8ae..1071839 100644
Binary files a/obj/main.o and b/obj/main.o differ

commit b38482592af77956ccb77af3f1de3a792fd9bd5b
Author: Massiouane Maibeche <massiouane.maibeche@etud-upem.fr>
Date:   Wed Jan 11 15:34:19 2023 +0100

    amelioration detection objet + gestion de retour vers mana

diff --git a/src/Collision.c b/src/Collision.c
index 8ea7384..fa9bc8f 100644
--- a/src/Collision.c
+++ b/src/Collision.c
@@ -22,16 +22,24 @@ pour voir ce qu'il va y trouver*/
 
 
 
+int est_dans_zone_objet(Position *joueur, Position_obj *objet){
+    if(joueur->x >= objet->x - MARGE_DISTANCE && joueur->x <= objet->x + MARGE_DISTANCE &&
+        joueur->y >= objet->y - MARGE_DISTANCE && joueur->y <= objet->y + MARGE_DISTANCE){
+            return 1;
+        }
+    return 0;
+}
+
 
 /*Renvoie 1 si coord j est ds relique et 0 sinon*/
-int est_dans_relique(Joueur const *joueur, Relique const *relique){
+/*int est_dans_relique(Joueur const *joueur, Relique const *relique){
     return ((int)(joueur->pos.x) == relique->pos.x && (int)(joueur->pos.y) == relique->pos.y) ? 1 : 0;
-}
+}*/
 
-/*Renvoie 1 si coord j est ds relique et 0 sinon*/
+/*Renvoie 1 si coord j est ds relique et 0 sinon*//*
 int est_dans_tuile(Joueur const *joueur, Tuile const *tuile){
     return ((int)(joueur->pos.x) == tuile->pos.x && (int)(joueur->pos.y) == tuile->pos.y) ? 1 : 0;
-}
+}*/
 
 
 
@@ -88,7 +96,7 @@ static void collision_coin_haut_gauche(Plateau const *plateau, Position *pos, do
     /*A CHANGER >>*/
     if(distance_du_mur > 1){return ;}
     switch(*dir_tmp){
-        case GAUCHE: if(pos->x < (int)(pos->x) + 0.5){
+        case GAUCHE: if(pos->x > (int)(pos->x) + 0.5){
                         if((int)(pos->y) + (*vitesse) > (int)(pos->y) + 1 - sqrt((1.0/4 - (pos->x - (int)(pos->x)) * (pos->x - (int)(pos->x))))){
                             *vitesse = 0.0;
                         }
@@ -181,32 +189,32 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
     distance_du_mur = distance_vers_mur(plateau, pos, dir);
     if(distance_du_mur > 1) return 0;
     switch(*dir){
-        case HAUT : if((int)(pos->y) - (*vitesse) > (int)(pos->y) + 0.5){
-                        *vitesse = 0.0;
+        case HAUT : if((int)(pos->y)  > (int)(pos->y) + 0.5){
+                        *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = DROITE;
                     collision_coin_haut_droite(plateau, pos, vitesse, &tmp_dir);
                     tmp_dir = GAUCHE;
                     collision_coin_haut_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case BAS :  if((int)(pos->y) + (*vitesse ) > (int)(pos->y) + 0.5){
-                        *vitesse = 0.0;
+        case BAS :  if((int)(pos->y)  > (int)(pos->y) + 0.5){
+                        *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = DROITE;
                     collision_coin_bas_droite(plateau, pos, vitesse, &tmp_dir);
                     tmp_dir = GAUCHE;
                     collision_coin_bas_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case GAUCHE : if((int)(pos->x) - (*vitesse ) > (int)(pos->x) + 0.5){
-                        *vitesse = 0.0;
+        case GAUCHE : if((int)(pos->x)  > (int)(pos->x) + 0.5){
+                        *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = BAS;
                     collision_coin_bas_gauche(plateau, pos, vitesse, &tmp_dir);
                     tmp_dir = HAUT;
                     collision_coin_haut_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case DROITE : if((int)(pos->x) + (*vitesse ) > (int)(pos->x) + 0.5){
-                        *vitesse = 0.0;
+        case DROITE : if((int)(pos->x)  > (int)(pos->x) + 0.5){
+                        *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = BAS;
                     collision_coin_bas_droite(plateau, pos, vitesse, &tmp_dir);
diff --git a/src/Deplacement.c b/src/Deplacement.c
index 37a6d1e..688ad49 100644
--- a/src/Deplacement.c
+++ b/src/Deplacement.c
@@ -1,12 +1 @@
 #include "../include/Deplacement.h"
-
-void change_direction(Position *p, Direction direction){
-    assert(NULL != p);
-    switch(direction){
-        case HAUT : p->x -= 1; break;
-        case BAS : p->y -= 1; break;
-        case GAUCHE : p->x += 1; break;
-        case DROITE : p->y += 1; break;
-        default : break;
-    }
-}
diff --git a/src/Gardien.c b/src/Gardien.c
index a1f8c62..18db4b5 100644
--- a/src/Gardien.c
+++ b/src/Gardien.c
@@ -13,11 +13,11 @@ mode panique si relique disparu
 
 
 /*attribue une vitesse aleatoire*/
-void change_vitesse_gardien(Etat_gardien *etat, float *vitesse){
+void change_vitesse_gardien(Etat_gardien *etat, double/*float*/ *vitesse){
     assert(NULL != vitesse);
     assert(NULL != etat);
     switch(*etat){
-        case MODE_NORMAL : *vitesse = (30.0 + rand() % (80 - 30)) / 100.0; break;
+        case MODE_NORMAL : *vitesse = (10.0 + rand() % (50 - 10)) / 100.0; break;
         case MODE_PANIQUE : *vitesse = 1.0; break;
         default : printf("mode non reconnu - vitesse nulle"); *vitesse = 0.0; break;
     }
@@ -31,9 +31,9 @@ void change_direction_(Direction *d){
     int pos;
     assert(NULL != d);
     do{
-        pos = rand() % 4;
-    }while(pos == *d);
-    *d = pos;
+        pos = rand();
+    }while((pos % 4) == *d);
+    *d = pos % 4;
 }
 
 /*configure le mode normal*/
@@ -68,7 +68,6 @@ void initalise_gardien(Gardien *g){
     printf("(champs à ingnoré)-> direction initial = %d\n", g->direction);
     /*init_coord_aleatoire(&(g->pos));*/
     config_gardien_mode_normal(g);
-
 }
 
 
diff --git a/src/Gestion_terrain.c b/src/Gestion_terrain.c
index 1caccd0..987d334 100644
--- a/src/Gestion_terrain.c
+++ b/src/Gestion_terrain.c
@@ -23,7 +23,8 @@ int interaction_joueur_relique(Plateau *p){
     int i;
     assert(NULL != p);
     for(i = 0; i < NB_RELIQUE; ++i){
-        if(est_dans_relique(&(p->joueur), &(p->relique[i])) && p->relique[i].etat == NON_RECUPERER){
+        /*est_dans_relique(&(p->joueur), &(p->relique[i]))*/
+        if(est_dans_zone_objet(&(p->joueur.pos), &(p->relique[i].pos)) && p->relique[i].etat == NON_RECUPERER){
             change_etat_obj(&(p->relique[i].etat));
             p->joueur.nb_relique++;
             return 1;
@@ -37,9 +38,11 @@ int interaction_joueur_tuile(Plateau *p){
     int i;
     assert(NULL != p);
     for(i = 0; i < NB_TUILE; ++i){
-        if(est_dans_tuile(&(p->joueur), &(p->tuile[i])) && p->tuile[i].etat == NON_RECUPERER){
+        /*est_dans_tuile(&(p->joueur), &(p->tuile[i]))*/
+        if(est_dans_zone_objet(&(p->joueur.pos), &(p->tuile[i].pos)) && p->tuile[i].etat == NON_RECUPERER){
             change_etat_obj(&(p->tuile[i].etat));
             p->joueur.mana += p->tuile[i].mana;
+            p->tuile[i].mana = 0;
             return 1;
         }
     }
@@ -47,22 +50,158 @@ int interaction_joueur_tuile(Plateau *p){
 }
 
 
-void interaction_gardien_gardien(){
+static int gardien_meme_position(Gardien *gardien_1, Gardien *gardien_2){
+    return ((int)gardien_1->pos.x == (int)gardien_2->pos.x && (int)gardien_1->pos.y == (int)gardien_2->pos.y) ? 1 : 0;
+}
+
+/*Fonction O.K*/
+void interaction_gardien_gardien(Plateau *plateau){
+    int i, j;
+    for(i = 0; i < NB_GARDIEN; ++i){
+        for(j = 0; j < NB_GARDIEN; ++j){
+            if(j != i && gardien_meme_position(&(plateau->gardien[i]), &(plateau->gardien[j]))){
+                change_direction_(&(plateau->gardien[i].direction));
+                change_vitesse_gardien(&(plateau->gardien[i].alerte), &(plateau->gardien[i].vitesse));
+
+                change_direction_(&(plateau->gardien[j].direction));
+                change_vitesse_gardien(&(plateau->gardien[j].alerte), &(plateau->gardien[j].vitesse));
+                /*printf("Interaction_gardien_gardien ==> wait(1sec)\n");
+                sleep(1);*/
+            }
+        }
+    }
+}
 
-    return ;
+
+static void gestion_mode_joueur(Joueur *joueur, MLV_Keyboard_modifier *mod, int *cpt){
+    assert(NULL != joueur);
+
+    if(MLV_shift_key_was_pressed(*mod) && joueur->mana >= 2){
+        printf("Tu as pressé la touche shift\n");
+        joueur->mode = MODE_ACCELERE;
+        joueur->mana -= 2;
+        *cpt += 2;
+    }
+    else if(MLV_get_keyboard_state(MLV_KEYBOARD_SPACE) == MLV_PRESSED/*MLV_shift_key_was_pressed(*mod)*/ && joueur->mana >= 1){
+        printf("Tu as pressé la touche espace\n");
+        joueur->mode = MODE_INVISIBLE;
+        joueur->mana -= 1;
+        *cpt += 1;
+    }
+    else{
+        joueur->mode = MODE_NORMAL;
+    }
 }
 
 /*interaction_joueur_mur ==> a gerer dans les deplacment du joueur*/
-void deplacement_joueur(Plateau *p){
-    assert(NULL != p);
-    return ;
+void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_state *state, MLV_Keyboard_modifier *mod){
+
+    gestion_mode_joueur(&(plateau->joueur), mod, &(plateau->cpt_mana));
+    if(*sym == MLV_KEYBOARD_z && *state == MLV_PRESSED){
+        plateau->joueur.direction = HAUT;
+        if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
+            augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
+            plateau->joueur.pos.y -= plateau->joueur.vitesse; /*printf("P-HAUT ");*/
+        }
+    }
+    else if(*sym == MLV_KEYBOARD_s && *state == MLV_PRESSED){
+        plateau->joueur.direction = BAS;
+        if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
+            augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
+            plateau->joueur.pos.y += plateau->joueur.vitesse; /*printf("P-BAS ");*/
+        }
+
+    }
+    else if(*sym == MLV_KEYBOARD_q && *state == MLV_PRESSED){
+        plateau->joueur.direction = GAUCHE;
+        if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
+            augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
+            plateau->joueur.pos.x -= plateau->joueur.vitesse; /*printf("P-GAUCHE ");*/
+        }
+    }
+    else if(*sym == MLV_KEYBOARD_d && *state == MLV_PRESSED){
+        plateau->joueur.direction = DROITE;
+        if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
+            augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
+            plateau->joueur.pos.x += plateau->joueur.vitesse; /*printf("P-DROITE ");*/
+        }
+    }
+    else{
+        plateau->joueur.vitesse = VITESSE_NULLE;
+    }
 }
 
+void retour_mana_vers_tuile(Plateau *plateau){
+    int i, quantite_mana;
+    if((plateau->cpt_mana % 60) != 0 || plateau->cpt_mana <= 0){
+        return;
+    }
+    for(i = 0; i < NB_TUILE; ++i){
+        if(plateau->cpt_mana == 0){
+            return;
+        }
+        quantite_mana = plateau->tuile[i].mana;
+        if(quantite_mana == 0 && plateau->tuile[i].etat == RECUPERER){
+            plateau->cpt_mana -= QUANTITE_MANA_TUILE;
+            plateau->tuile[i].mana += QUANTITE_MANA_TUILE;
+            change_etat_obj(&(plateau->tuile[i].etat));
+        }
+    }
+}
+
+static void effectue_deplacement_gardien(Gardien *g){
+    switch(g->direction){
+        case HAUT : g->pos.y -= g->vitesse; break;
+        case BAS : g->pos.y += g->vitesse; break;
+        case GAUCHE : g->pos.x -= g->vitesse; break;
+        case DROITE : g->pos.x += g->vitesse; break;
+        default : break;
+    }
+}
+
+static void direction_opposer(Direction *d){
+    switch(*d){
+        case HAUT : *d = BAS; break;
+        case BAS : *d = HAUT; break;
+        case GAUCHE : *d = DROITE; break;
+        case DROITE : *d = GAUCHE; break;
+        default : break;
+    }
+}
+
+void deplacement_gardien(Plateau *plateau){
+    int i, tmp, flag;
+
+    for(i = 0; i < NB_GARDIEN; ++i){
+        tmp = rand() % 50;
+        flag = 0;
+        /*collision_contre_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction), &(plateau->gardien[i].vitesse)) == 1*/
+        /*!collision_contre_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction), &(plateau->gardien[i].vitesse))*/
+        /*distance_vers_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction)) > 1*/
+        if(!collision_contre_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction), &(plateau->gardien[i].vitesse))){
+            if(tmp == 0){
+                change_direction_(&(plateau->gardien[i].direction));
+                change_vitesse_gardien(&(plateau->gardien[i].alerte), &(plateau->gardien[i].vitesse));
+            }
+            effectue_deplacement_gardien(&(plateau->gardien[i]));
+        }
+        else{
+            if(flag == 0){
+                direction_opposer(&(plateau->gardien[i].direction));
+            }
+            change_vitesse_gardien(&(plateau->gardien[i].alerte), &(plateau->gardien[i].vitesse));
+            effectue_deplacement_gardien(&(plateau->gardien[i]));
+        }
+        /*printf("n°%d - dir = %d\n", i, plateau->gardien[i].direction);*/
+    }
+}
+
+
 int fin_de_jeu(Joueur const *j){
-    if((int)j->pos.x == COORD_FIN_DE_JEU_X &&
-        (int)j->pos.y == COORD_FIN_DE_JEU_Y &&
-        j->nb_relique == NB_RELIQUE){
+    if(j->pos.x >= COORD_FIN_DE_JEU_X - MARGE_DISTANCE && j->pos.x <= COORD_FIN_DE_JEU_X + MARGE_DISTANCE &&
+        j->pos.y >= COORD_FIN_DE_JEU_Y - MARGE_DISTANCE && j->pos.y <= COORD_FIN_DE_JEU_Y + MARGE_DISTANCE &&
+         j->nb_relique == NB_RELIQUE){
             return 1;
-        }
+    }
     return 0;
 }
diff --git a/src/Moteur_de_jeu.c b/src/Moteur_de_jeu.c
index da39e21..bca5511 100644
--- a/src/Moteur_de_jeu.c
+++ b/src/Moteur_de_jeu.c
@@ -28,141 +28,215 @@ void init_coord_aleatoire(Position *pos){
 
 */
 
-static void make_wall_on_board(int i,int j ,int nb,int direction ,Plateau * game){
+/*Fabrique le côté des murs*/
+static void make_wall_on_board(int i, int j, int nb, int direction, Plateau *game){
     /*printf("Poser a la position x %d et y %d avec un nb de %d\n",i,j,nb);*/
     int cpt;
-    if(nb==0){
+
+    assert(NULL != game);
+
+    if(nb == 0){
         return;
     }
-    if(direction ==0){
-        for(cpt=1;cpt<nb+1;cpt++){
-            game->plateau[i][j+cpt]=1;
+    if(direction == 0){
+        for(cpt = 1; cpt < nb + 1; cpt++){
+            game->plateau[i][j + cpt] = MUR;
         }
     }
-    if(direction ==1){
-        for(cpt=1;cpt<nb+1;cpt++){
-            game->plateau[i][j-cpt]=1;
+    if(direction == 1){
+        for(cpt = 1; cpt < nb + 1; cpt++){
+            game->plateau[i][j - cpt] = MUR;
         }
     }
-    if(direction ==2){
-        for(cpt=1;cpt<nb+1;cpt++){
-            game->plateau[i+cpt][j]=1;
+    if(direction == 2){
+        for(cpt = 1; cpt < nb + 1; cpt++){
+            game->plateau[i + cpt][j] = MUR;
         }
     }
-    if(direction ==3){
-        for(cpt=1;cpt<nb+1;cpt++){
-            game->plateau[i-cpt][j]=1;
+    if(direction == 3){
+        for(cpt = 1; cpt < nb + 1; cpt++){
+            game->plateau[i-cpt][j] = MUR;
         }
     }
 }
 
-static int verification_case(int i ,int j ,Plateau game,int direction ){
-    int x,y;
-    if(i>8 && direction !=3 &&direction !=2){
-        for(x =1;x<minside;x++){
-            if(game.plateau[i-x][j]==1){
-           /*printf(" i = %d j = %d direction = %d 1\n",i,j,direction);*/return 0;}
-        }
+/**/
+static int verification_case(int i, int j, Plateau const *game, int direction){
+    int x, y;
+
+    assert(NULL != game);
 
+    if(i > minside - 1 && direction != 3 && direction != 2){
+        for(x = 1; x < minside; x++){
+            if(game->plateau[i - x][j] == MUR){
+                /*printf(" i = %d j = %d direction = %d 1\n", i, j, direction);*/
+                return 0;
+            }
+        }
     }
-    if(i<LARGEUR_PLATEAU-10 && direction !=2&&direction !=3){
-        for ( y = 1; y < minside; y++){
-            if(game.plateau[i+y][j]==1){
-            /*printf(" i = %d j = %d direction = %d 2\n",i,j,direction);*/return 0;}
+    if(i < LARGEUR_PLATEAU - 10 && direction != 2 && direction != 3){
+        for(y = 1; y < minside; y++){
+            if(game->plateau[i + y][j] == MUR){
+                /*printf(" i = %d j = %d direction = %d 2\n", i, j, direction);*/
+                return 0;
+            }
         }
     }
-    if(j<LONGEUR_PLATEAU-10 && direction !=0 && direction !=1 ){
-        for(x =1 ;x<minside;x++){
-            if(game.plateau[i][j+x]==1){/*printf("i = %d j = %d direction = %d 3\n",i,j,direction);*/return 0;}
+    if(j < LONGEUR_PLATEAU - 10 && direction != 0 && direction != 1){
+        for(x = 1; x < minside; x++){
+            if(game->plateau[i][j + x] == MUR){
+                /*printf("i = %d j = %d direction = %d 3\n",i,j,direction);*/
+                return 0;
+            }
         }
     }
-    if(j>8 && direction !=1 && direction !=0){
-        for(y =1;y< minside;y++){
-            if(game.plateau[i][j-y]==1){/*printf(" i = %d j = %d direction = %d 4\n",i,j,direction);*/return 0;}
+    if(j > minside - 1 && direction != 1 && direction != 0){
+        for(y = 1; y < minside; y++){
+            if(game->plateau[i][j - y] == MUR){
+                /*printf(" i = %d j = %d direction = %d 4\n",i,j,direction);*/
+                return 0;
+            }
         }
     }
     return 1;
-
 }
 
 
-static int lenght_of_wall_verification(int x,int y,Plateau game,int direction){
-    int i, j, cpt = 0;
-   /*printf("lenght_of_wall_verification x = %d y = %d direction =%d \n",x,y,direction);*/
+static int lenght_of_wall_verification(int x, int y, Plateau const *game, int direction){
+    int i, j, cpt;
+
+    assert(NULL != game);
+
+    cpt = 0;
+    /*printf("lenght_of_wall_verification x = %d y = %d direction =%d \n",x,y,direction);*/
     if(direction == 0 && y < LONGEUR_PLATEAU - 1){
         for(j = y + 1; j < LONGEUR_PLATEAU; ++j){
-            if(game.plateau[x][j]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
-            if(verification_case(x, j, game, direction) == 0){/*printf("lenght_of_wall_verification return 0\n");*/return 0;}
+            if(game->plateau[x][j] == 1){
+                /*printf("lenght_of_wall_verification return %d \n",cpt);*/
+                return cpt;
+            }
+            if(verification_case(x, j, game, direction) == 0){
+                /*printf("lenght_of_wall_verification return 0\n");*/
+                return 0;
+            }
             ++cpt;
         }
     }
     else if(direction == 1 && y > 0){
         for(j = y - 1; j >= 0; --j){
-            if(game.plateau[x][j] == 1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
-            if(verification_case(x, j, game, direction) == 0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+            if(game->plateau[x][j] == 1){
+                /*printf("lenght_of_wall_verification return %d \n",cpt);*/
+                return cpt;
+            }
+            if(verification_case(x, j, game, direction) == 0){
+                /*printf("lenght_of_wall_verification return 0 \n");*/
+                return 0;
+            }
             ++cpt;
         }
     }
     else if(direction == 3 && x > 0){
-        for ( i = x-1; i>=0; i--){
-           if(game.plateau[i][y]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
-            if(verification_case(i,y,game,direction)==0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+        for(i = x - 1; i >= 0; i--){
+            if(game->plateau[i][y] == 1){
+                /*printf("lenght_of_wall_verification return %d \n",cpt);*/
+                return cpt;
+            }
+            if(verification_case(i, y, game, direction) == 0){
+                /*printf("lenght_of_wall_verification return 0 \n");*/
+                return 0;
+            }
             cpt++;
         }
     }
-    else if(direction == 2 && x < LARGEUR_PLATEAU-1){
-        for ( i = x+1; i<LARGEUR_PLATEAU; i++){
-            if(game.plateau[i][y]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
-            if(verification_case(i,y,game,direction)==0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+    else if(direction == 2 && x < LARGEUR_PLATEAU - 1){
+        for(i = x + 1; i < LARGEUR_PLATEAU; i++){
+            if(game->plateau[i][y] == MUR){
+                /*printf("lenght_of_wall_verification return %d \n",cpt);*/
+                return cpt;
+            }
+            if(verification_case(i, y, game, direction) == 0){
+                /*printf("lenght_of_wall_verification return 0 \n");*/
+                return 0;
+            }
             cpt++;
         }
     }
     /*printf("return 0\n");*/
     return 0;
-
 }
 
-static int line_of_wall_respected(int x ,int y ,Plateau game,int direction){
-    int i,j,cpt=0;
+static int line_of_wall_respected(int x, int y, Plateau const *game, int direction){
+    int i, j, cpt;
+
+    assert(NULL != game);
+
+    i = 0, j = 0, cpt = 0;
+
     /*printf(" line_of_wall_respected avec x %d et y %d et direction %d \n",x,y,direction);*/
-    if((direction == 0 || direction ==1)){
-        if((direction==0&& y>LONGEUR_PLATEAU-1) ||(direction==1&& y<1)){/*printf("line_of_wall_respected return 1 \n");*/return 0;}
-        for(i = x ; i<LARGEUR_PLATEAU;i++){
-            if(direction == 0 && game.plateau[i][y+1]==1){ /*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside +1 ? 1:0;}
-            if(direction == 1  && game.plateau[i][y-1]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
+    if((direction == 0 || direction == 1)){
+        if((direction == 0 && y > LONGEUR_PLATEAU - 1) || (direction == 1 && y < 1)){
+            /*printf("line_of_wall_respected return 1 \n");*/
+            return 0;
+        }
+        for(i = x; i < LARGEUR_PLATEAU; i++){
+            if(direction == 0 && game->plateau[i][y + 1] == MUR){
+                /*printf("line_of_wall_respected return %d \n",cpt);*/
+                return (cpt >= minside + 1) ? 1 : 0;
+            }
+            if(direction == 1 && game->plateau[i][y - 1] == MUR){
+                /*printf("line_of_wall_respected return %d \n",cpt);*/
+                return (cpt >= minside + 1) ? 1 : 0;
+            }
             cpt++;
         }
     }
-    if((direction == 2 || direction ==3)){
-        if((direction ==2 && x > LARGEUR_PLATEAU-1)||(direction ==3 && x < 1)){/*printf("line_of_wall_respected return 0\n");*/return 0;}
-        for(j = y;j<LONGEUR_PLATEAU;j++){
-            if(direction ==2 && game.plateau[x+1][j]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
-            if(direction==3 && game.plateau[x-1][j]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
+    if((direction == 2 || direction == 3)){
+        if((direction == 2 && x > LARGEUR_PLATEAU - 1) || (direction == 3 && x < 1)){
+            /*printf("line_of_wall_respected return 0\n");*/
+            return 0;
+        }
+        for(j = y; j < LONGEUR_PLATEAU; j++){
+            if(direction == 2 && game->plateau[x + 1][j] == MUR){
+                /*printf("line_of_wall_respected return %d \n",cpt);*/
+                return (cpt >= minside + 1) ? 1 : 0;
+            }
+            if(direction == 3 && game->plateau[x - 1][j] == MUR){
+                /*printf("line_of_wall_respected return %d \n",cpt);*/
+                return (cpt >= minside + 1) ? 1 : 0;
+            }
             cpt++;
         }
     }
     /*printf("line_of_wall_respected return %d \n",cpt);*/
-    return cpt>= minside ? 1:0;
+    return (cpt >= minside) ? 1 : 0;
 }
 
 
-static void generation_wall_on_game_by_line(double line,int direction,int nb,Plateau * game){
+static void generation_wall_on_game_by_line(double line, int direction, int nb, Plateau *game){
     /*printf("nb = %d \n",nb);*/
-    int i,j,cpt;
-    if(direction ==0|| direction==1){
-        for ( j = 0; j < LONGEUR_PLATEAU; j++){
-            for ( i = 0; i < LARGEUR_PLATEAU; i++){
-                if(game->plateau[i][j]==1){cpt++;}
-                if (game->plateau[i][j]==0){cpt=0;}
+    int i, j, cpt;
+
+    assert(NULL != game);
+
+    cpt = i = j = 0;
+    if(direction == 0 || direction == 1){
+        for(j = 0; j < LONGEUR_PLATEAU; j++){
+            for(i = 0; i < LARGEUR_PLATEAU; i++){
+                if(game->plateau[i][j] == MUR){
+                    cpt++;
+                }
+                if(game->plateau[i][j] == VIDE){
+                    cpt = 0;
+                }
                 /*if(line_of_wall_respected(i,j,(*game),direction)==-1){break;}*/
-                if(cpt>=(int)line && line_of_wall_respected(i,j,(*game),direction)==1 ){
+                if(cpt >= (int)line && line_of_wall_respected(i, j, game, direction) == 1){
                     /*printf("Le cpt de la fonction principale = %d \n",cpt);*/
                     /*printf("On rentre dans la verification pricipale\n");*/
-                    if(lenght_of_wall_verification(i,j,(*game),direction)>6){
-                        printf(" accepte avec i = %d et j = %d \n",i,j);
-                        if (rand()%(nb)==0){
-                           printf(" rand   accepte\n");
-                            make_wall_on_board(i,j,lenght_of_wall_verification(i,j,(*game),direction)-3,direction,game);
+                    if(lenght_of_wall_verification(i, j, game, direction) > 6){
+                        printf(" accepte avec i = %d et j = %d \n", i, j);
+                        if(rand() % nb == 0){
+                            printf(" rand   accepte\n");
+                            make_wall_on_board(i, j, lenght_of_wall_verification(i, j, game, direction) - 3, direction, game);
                             return ;
                         }
                     }
@@ -170,21 +244,24 @@ static void generation_wall_on_game_by_line(double line,int direction,int nb,Pla
             }
         }
     }
-    if(direction ==2|| direction==3){
-        for ( i = 0; i < LARGEUR_PLATEAU; i++){
-            for ( j = 0; j< LONGEUR_PLATEAU; j++){
-                if(game->plateau[i][j]==1){cpt++;}
-                if (game->plateau[i][j]==0){ cpt=0;}
+    if(direction == 2 || direction == 3){
+        for(i = 0; i < LARGEUR_PLATEAU; i++){
+            for(j = 0; j < LONGEUR_PLATEAU; j++){
+                if(game->plateau[i][j] == MUR){
+                    cpt++;
+                }
+                if(game->plateau[i][j] == VIDE){
+                    cpt = 0;
+                }
                 /*if(line_of_wall_respected(i,j,(*game),direction)==-1){break;}*/
-                if(cpt>=(int)line && line_of_wall_respected(i,j,(*game),direction)==1 ){
+                if(cpt >= (int)line && line_of_wall_respected(i, j, game, direction) ==1){
                     /*printf("Le cpt de la fonction principale = %d \n",cpt);*/
                     /*printf("On rentre dans la verification pricipale\n");*/
-                    if(lenght_of_wall_verification(i,j,(*game),direction)>6){
-                        printf(" accepte avec i = %d et j = %d \n",i,j);
-
-                        if (rand()%(nb)==0){
+                    if(lenght_of_wall_verification(i, j, game, direction) > 6){
+                        printf(" accepte avec i = %d et j = %d \n", i, j);
+                        if(rand() % nb == 0){
                             printf(" rand   accepte\n");
-                            make_wall_on_board(i,j,lenght_of_wall_verification(i,j,(*game),direction)-3,direction,game);
+                            make_wall_on_board(i, j, lenght_of_wall_verification(i, j, game, direction) - 3, direction, game);
                             return ;
                         }
                     }
@@ -192,17 +269,23 @@ static void generation_wall_on_game_by_line(double line,int direction,int nb,Pla
             }
         }
     }
-
 }
 
 static void generation_lenght_wall(double height, double lenght, int nb, Plateau *game){
     double x, y, line;
     int mur;
+
+    assert(NULL != game);
+
     x = height < lenght ? lenght : height;
     y = height < lenght ? height : lenght;
-    if(x < (2 * minside + 1)){return ;}
+    if(x < (2 * minside + 1)){
+        return ;
+    }
     if(x < (4 * minside)){
-        if(rand() % 2 == 0){return ;}
+        if(rand() % 2 == 0){
+            return ;
+        }
     }
     line = x / 2;
     mur = rand() % 4 ;/* 0 droite, 1 gauche , 2 bas ,3 haut*/
@@ -214,87 +297,108 @@ static void generation_lenght_wall(double height, double lenght, int nb, Plateau
 
 
 static void generation_wall_ext(Plateau *game){
-    int i,j;
-    for (i= 0; i < LARGEUR_PLATEAU; i++)
-    {
-        for(j =0;j<LONGEUR_PLATEAU;j++){
-            if(i == 0 || i ==44||j == 0 || j == 59){
-                game->plateau[i][j] = 1;
+    int i, j;
+
+    assert(NULL != game);
+
+    for(i = 0; i < LARGEUR_PLATEAU; i++){
+        for(j = 0; j < LONGEUR_PLATEAU; j++){
+            if(i == 0 || i == LARGEUR_PLATEAU - 1 || j == 0 || j == LONGEUR_PLATEAU - 1){
+                game->plateau[i][j] = MUR;
             }
             else{
-                game->plateau[i][j] = 0;
+                game->plateau[i][j] = VIDE;
             }
         }
     }
+}
 
 
-}
 
+static int not_on_openside(int x, int y, Plateau const *game){
+    int i, hor, vertic;
 
+    assert(NULL != game);
 
-static int not_on_openside(int x,int y , Plateau game){
-    int i ,hor=0,vertic=0;
-    for(i=1;i<=3;i++){
-        if(game.plateau[x-i][y]==1){
-            hor+=1;
+    i = 0, hor = 0, vertic = 0;
+    printf("-->>>x = %d:y = %d\n", x, y);
+    for(i = 1; i <= 3; i++){
+        if(game->plateau[x - i][y] == MUR){
+            hor++;
             break;
         }
     }
-    for(i=1;i<=3;i++){
-        if(game.plateau[x+i][y]==1){
-            hor+=1;
+    for(i = 1; i <= 3; i++){
+        if(game->plateau[x + i][y] == MUR){
+            hor++;
             break;
         }
     }
-    if(hor==2){return 0;}
-    for(i=1;i<=3;i++){
-        if(game.plateau[x][y-i]==1){
-            vertic+=1;
+    for(i = 1; i <= 3; i++){
+        if(game->plateau[x][y - i] == MUR){
+            vertic++;
             break;
         }
     }
-     for(i=1;i<=3;i++){
-        if(game.plateau[x][y+i]==1){
-            vertic+=1;
+    for(i = 1; i <= 3; i++){
+        if(game->plateau[x][y + i] == MUR){
+            vertic++;
             break;
         }
     }
-    if(vertic==2){return 0;}
+    if(vertic == 2 || hor == 2){
+        return 0;
+    }
     return 1;
-
 }
-static int position_verification(int x,int y ,Plateau game){
-    if(game.plateau[x][y] == 0 && sqrt((1-x)*(1-x)+(1-y)*(1-y)) >= 20 && not_on_openside(x,y,game)==1){
+
+
+static int position_verification(int x, int y, Plateau const *game){
+    int value;
+
+    assert(NULL != game);
+    printf("|||||||||\n\nx = %d - y = %d||||||||||||||||||||\n\n", x, y);
+    value = (int)(sqrt((1 - x)*(1 - x) + (1 - y)*(1 - y)));
+    if(game->plateau[x][y] == VIDE && value >= DISTANCE_MIN_JOUEUR_GARDIEN_OBJ && not_on_openside(x, y, game) == 1){
         return 1;
     }
     return 0;
 }
-static void init_Gardien(Plateau * game){
-    int i,x,y;
-    for ( i = 0; i < NB_GARDIEN; i++)
-    {
-        initalise_gardien(&game->gardien[i]);
+
+
+static void init_Gardien(Plateau *game){
+    int i, x, y;
+
+    assert(NULL != game);
+
+    x = 0, y = 0;
+    for(i = 0; i < NB_GARDIEN; i++){
+        initalise_gardien(&(game->gardien[i]));
         while(1){
-            x = rand()%57+1;
-            y=rand()%42+1;
-            if(position_verification(x,y,*game)==1){
+            x = 1 + rand() % 57;
+            y = 1 + rand() % 42;
+            if(position_verification(x, y, game) == 1){
                 game->gardien[i].pos.x = x;
                 game->gardien[i].pos.y = y;
                 break;
             }
         }
     }
-
 }
 
-static void init_Relique(Plateau * game){
-    int i,x,y;
-    for(i=0;i<NB_RELIQUE;i++){
-        initialise_relique(&game->relique[i]);
+static void init_Relique(Plateau *game){
+    int i, x, y;
+
+    assert(NULL != game);
+
+    x = 0, y = 0;
+    for(i = 0; i < NB_RELIQUE; i++){
+        printf("relique");
+        initialise_relique(&(game->relique[i]));
         while(1){
-            x = rand()%57+1;
-            y=rand()%42+1;
-            if(position_verification(x,y,*game)==1){
+            x = 1 + rand() % 57;
+            y = 1 + rand() % 42;
+            if(position_verification(x, y, game) == 1){
                 game->relique[i].pos.x = x;
                 game->relique[i].pos.y = y;
                 break;
@@ -303,16 +407,20 @@ static void init_Relique(Plateau * game){
     }
 }
 
-static void init_tuile(Plateau * game){
+static void init_tuile(Plateau *game){
+    int i, x, y;
+
+    assert(NULL != game);
 
-    int i ,x,y;
-    for(i=0;i<NB_TUILE;i++){
-        game->tuile[i].mana = 60;
+    x = 0, y = 0;
+    for(i = 0; i < NB_TUILE; i++){
+        printf("tuile");
+        game->tuile[i].mana = QUANTITE_MANA_TUILE;
         game->tuile[i].etat = NON_RECUPERER;
         while(1){
-            x = 1 + rand() % 57;
+            x = 1 + rand() % 56;
             y = 1 + rand() % 42;
-            if(position_verification(x, y, *game) == 1){
+            if(position_verification(x, y, game) == 1){
                 game->tuile[i].pos.x = x;
                 game->tuile[i].pos.y = y;
                 break;
@@ -323,61 +431,71 @@ static void init_tuile(Plateau * game){
 
 static void init_plateau(Plateau *p){
     int i, j;
+
+    assert(NULL != p);
+
     for(i = 0; i < LARGEUR_PLATEAU; ++i){
         for(j = 0; j < LONGEUR_PLATEAU; ++j){
-            p->plateau[i][j] = 0;
+            p->plateau[i][j] = VIDE;
         }
     }
 }
 
 
-static void init_objects_in_map(Plateau * game){
-    int i ;
-    initialise_joueur(&game->joueur);
-    printf(" x = %.0f \n",game->joueur.pos.x);
+static void init_objects_in_map(Plateau *game){
+    int i;
+
+    assert(NULL != game);
+
+    initialise_joueur(&(game->joueur));
+    printf(" x = %.0f \n", game->joueur.pos.x);
+    game->cpt_mana = 0;
     init_Gardien(game);
     init_Relique(game);
     init_tuile(game);
-    game->plateau[(int)game->joueur.pos.x][(int)game->joueur.pos.y] = 4;
-    for(i = 0;i<NB_GARDIEN;i++){
-        game->plateau[(int)game->gardien[i].pos.x][(int)game->gardien[i].pos.y] =2;
-        printf("poser gardien %.0f %.0f \n",game->gardien[i].pos.x,game->gardien[i].pos.y);
-
-
+    game->plateau[(int)game->joueur.pos.x][(int)game->joueur.pos.y] = JOUEUR;
+    for(i = 0; i < NB_GARDIEN; i++){
+        game->plateau[(int)(game->gardien[i].pos.x)][(int)(game->gardien[i].pos.y)] = GARDIEN;
+        printf("poser gardien %.0f %.0f \n",game->gardien[i].pos.x, game->gardien[i].pos.y);
     }
-    for(i = 0;i<NB_RELIQUE;i++){
-        game->plateau[game->relique[i].pos.x][game->relique[i].pos.y]=3;
+    for(i = 0; i < NB_RELIQUE; i++){
+        game->plateau[game->relique[i].pos.x][game->relique[i].pos.y] = RELIQUE;
         printf("poser relique\n");
-
     }
-    for(i = 0;i<NB_TUILE;i++){
-        game->plateau[game->tuile[i].pos.x][game->tuile[i].pos.y]=5;
+    for(i = 0; i < NB_TUILE; i++){
+        game->plateau[game->tuile[i].pos.x][game->tuile[i].pos.y] = TUILE;
         printf("poser tuile\n");
     }
-
 }
-static void generation_wall_ext_print(Plateau game){
-    int i,j;
-    for (i= 0; i < LARGEUR_PLATEAU; i++)
-    {
-        for(j =0;j<LONGEUR_PLATEAU;j++){
-            printf("%d ",game.plateau[i][j]);
+
+
+static void generation_wall_ext_print(Plateau const *game){
+    int i, j;
+    for(i = 0; i < LARGEUR_PLATEAU; i++){
+        for(j = 0; j < LONGEUR_PLATEAU; j++){
+            if(game->plateau[i][j] == 0){
+                printf("  ");
+            }
+            else{
+                printf("%d ", game->plateau[i][j]);
+            }
         }
         printf("\n");
     }
-
-
 }
 
+
 void create_map(Plateau *game){
+    assert(NULL != game);
+
     init_plateau(game);
     generation_wall_ext(game);
-    generation_lenght_wall(58.0,43.0,1,game);
+    generation_lenght_wall(58.0, 43.0, 1, game);
     printf(" Le plateau de jeu apres : \n");
-    /*generation_wall_ext_print(*game);*/
+    generation_wall_ext_print(game);
     printf(" Le plateau de jeu apres  object : \n");
     init_objects_in_map(game);
-    /*generation_wall_ext_print(*game);*/
+    generation_wall_ext_print(game);
 }
 
 
diff --git a/src/Moteur_graphique.c b/src/Moteur_graphique.c
index 03a85dd..7bba30b 100644
--- a/src/Moteur_graphique.c
+++ b/src/Moteur_graphique.c
@@ -59,10 +59,10 @@ static void dessine_relique(Plateau const *p){
                                                         p->relique[i].pos.y * TAILLE_CASE,
                                                          TAILLE_CASE / 2, MLV_COLOR_LIGHT_BLUE);
                                break;
-            case RECUPERER : MLV_draw_filled_circle(p->relique[i].pos.x * TAILLE_CASE,
+            /*case RECUPERER : MLV_draw_filled_circle(p->relique[i].pos.x * TAILLE_CASE,
                                                         p->relique[i].pos.y * TAILLE_CASE,
                                                          TAILLE_CASE / 2, MLV_COLOR_PURPLE);
-                                break;
+                                break;*/
 
             default : break;
         }
@@ -128,7 +128,7 @@ void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur){
         }
     }
     dessine_gardien(p);
-    dessine_relique(p);
     dessine_tuile(p);
+    dessine_relique(p);
     MLV_actualise_window();
 }
diff --git a/src/main.c b/src/main.c
index 27b458a..026f5da 100644
--- a/src/main.c
+++ b/src/main.c
@@ -4,7 +4,6 @@
 
 #include "../include/Gestion_terrain.h"
 #include "../include/Moteur_graphique.h"
-#include "MLV/MLV_all.h"
 #include <time.h>
 
 static void aff_plat(Plateau *plat){
@@ -18,35 +17,12 @@ static void aff_plat(Plateau *plat){
             else{
                 printf("%d ", plat->plateau[i][j]);
             }
-
         }
         printf("\n");
     }
     printf("\n\n");
 }
 
-/*Ancienne version */
-/*
-if(MLV_get_keyboard_state(MLV_KEYBOARD_z) == MLV_PRESSED){
-    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-    plateau.joueur.pos.y -= plateau.joueur.vitesse; printf("P-HAUT ");
-}
-else if(MLV_get_keyboard_state(MLV_KEYBOARD_s) == MLV_PRESSED){
-    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-    plateau.joueur.pos.y += plateau.joueur.vitesse; printf("P-BAS ");
-}
-else if(MLV_get_keyboard_state(MLV_KEYBOARD_q) == MLV_PRESSED){
-    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-    plateau.joueur.pos.x -= plateau.joueur.vitesse; printf("P-GAUCHE ");
-}
-else if(MLV_get_keyboard_state(MLV_KEYBOARD_d) == MLV_PRESSED){
-    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-    plateau.joueur.pos.x += plateau.joueur.vitesse; printf("P-DROITE ");
-}
-else{
-    plateau.joueur.vitesse = 0;
-}
-*/
 
 
 int main(int argc, const char * const argv[]){
@@ -59,111 +35,50 @@ int main(int argc, const char * const argv[]){
     MLV_Keyboard_button sym;
     MLV_Button_state state;
     MLV_Event event;
+    frametime = extratime = 0.0;
+    fin_de_partie = 1;
+    mod = MLV_KEYBOARD_KMOD_NONE;
+    sym = MLV_KEYBOARD_NONE;
+    state = MLV_RELEASED;
+    event = MLV_NONE;
 
-    /*srand(time(NULL));*/
+    srand(time(NULL));
     MLV_create_window("ko", "ka", LONGUEUR_FENETRE, LARGEUR_FENETRE);
     create_map(&plateau);
-    fin_de_partie = 1;
     /*aff_plat(&plateau);*/
 
     clock_gettime(CLOCK_REALTIME, &start);
-    plateau.joueur.direction = HAUT;
-    printf("H->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
-    plateau.joueur.direction = BAS;
-    printf("B->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
-    plateau.joueur.direction = GAUCHE;
-    printf("G->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
-    plateau.joueur.direction = DROITE;
-    printf("D->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
     while(fin_de_partie){
         /*CALCUL_DE_TEMPS*/
         clock_gettime(CLOCK_REALTIME, &end_time);
         dessine_plateau_graphique(&plateau, LONGEUR_PLATEAU, LARGEUR_PLATEAU);
-
         event = MLV_get_event(&sym, &mod, NULL, NULL, NULL, NULL, NULL, NULL, &state);
-        printf("state %d: \n", state);
-
-        if(sym == MLV_KEYBOARD_z && state == MLV_PRESSED){
-            plateau.joueur.direction = HAUT;
-            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
-            }
-            else{
-                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-                plateau.joueur.pos.y -= plateau.joueur.vitesse; printf("P-HAUT ");
-            }
-        }
-        else if(sym == MLV_KEYBOARD_s && state == MLV_PRESSED){
-            plateau.joueur.direction = BAS;
-            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
-            }
-            else{
-                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-                plateau.joueur.pos.y += plateau.joueur.vitesse; printf("P-BAS ");
-            }
-
-        }
-        else if(sym == MLV_KEYBOARD_q && state == MLV_PRESSED){
-            plateau.joueur.direction = GAUCHE;
-            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
-            }
-            else{
-                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-                plateau.joueur.pos.x -= plateau.joueur.vitesse; printf("P-GAUCHE ");
-            }
-        }
-        else if(sym == MLV_KEYBOARD_d && state == MLV_PRESSED){
-            plateau.joueur.direction = DROITE;
-            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
-            }
-            else{
-                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-                plateau.joueur.pos.x += plateau.joueur.vitesse; printf("P-DROITE ");
-            }
-        }
-        else{
-            plateau.joueur.vitesse = 0;
-        }
-        switch(plateau.joueur.direction){
-            case HAUT :printf("H : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
-            case BAS :printf("B : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
-            case DROITE:printf("D : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
-            case GAUCHE:printf("G : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
-            default :break;
-        }
-
-        printf("vitesse:%f \n", plateau.joueur.vitesse);
+        /*printf("state %d: \n", state);*/
+        deplacement_joueur(&plateau, &sym, &state, &mod);
+        deplacement_gardien(&plateau);
+        /*printf("vitesse:%f \n", plateau.joueur.vitesse);*/
         if(event == MLV_KEY){
-            /*if(sym == MLV_KEYBOARD_z && state == MLV_PRESSED){
-                plateau.joueur.pos.y -= 1; printf("P-HAUT ");
-            }
-            else if(sym == MLV_KEYBOARD_s && state == MLV_PRESSED){
-                plateau.joueur.pos.y += 1; printf("P-BAS ");
-            }
-            else if(sym == MLV_KEYBOARD_q && state == MLV_PRESSED){
-                plateau.joueur.pos.x -= 1; printf("P-GAUCHE ");
-            }
-            else if(sym == MLV_KEYBOARD_d && state == MLV_PRESSED){
-                plateau.joueur.pos.x += 1; printf("P-DROITE ");
-            }*/
             if(sym == MLV_KEYBOARD_t){
                 aff_plat(&plateau);
                 break;
             }
         }
-
         /*Mecanisme de jeu et tt*/
         interaction_joueur_relique(&plateau);
         interaction_joueur_tuile(&plateau);
-        /* ... */
+        interaction_gardien_gardien(&plateau);
+        retour_mana_vers_tuile(&plateau);
+
+        /*framerate*/
         clock_gettime(CLOCK_REALTIME, &new_time);
         frametime = new_time.tv_sec - end_time.tv_sec;
         frametime += (new_time.tv_sec - end_time.tv_sec) / 1.0E9;
         extratime = (1.0 / 60) - frametime;
-        printf("(1.0/60.0) = %f\nextratime : %f\nframetime : %f\n",(1.0 / 60.0), extratime, frametime);
-
+        /*printf("(1.0/60.0) = %f\nextratime : %f\nframetime : %f\n",(1.0 / 60.0), extratime, frametime);*/
         if(extratime > 0){
             MLV_wait_milliseconds((int)(extratime * 1000));
         }
+        /*fin de partie*/
         if(fin_de_jeu(&(plateau.joueur))){
             fin_de_partie = 0;
         }
@@ -171,7 +86,12 @@ int main(int argc, const char * const argv[]){
     clock_gettime(CLOCK_REALTIME, &end);
     /*Chrono rapide du joueur - a ameliorer eventuellement ==> */
     printf("Durée de la partie = %.2fs\n",(double) ((end.tv_sec - start.tv_sec) + ((end.tv_nsec - start.tv_nsec) / 1.0E9)));
-
+    printf("plateau taille = %d\n", (int)sizeof(plateau));
+    printf("joeur taille = %d\n", (int)sizeof(plateau.joueur));
+    printf("gard taille = %d\n", (int)sizeof(plateau.gardien));
+    printf("tuile taille = %d\n", (int)sizeof(plateau.tuile));
+    printf("relique taille = %d\n", (int)sizeof(plateau.relique));
+    printf("plateau dejue taille = %d\n", (int)sizeof(plateau.plateau));
     MLV_free_window();
     return 0;
 }

commit fa73ccf449c159cfa678bced0a1b5cfad4524213
Author: Prashath Sivayanama <prashath.sivayanama@etud.u-pem.fr>
Date:   Wed Jan 11 13:59:26 2023 +0100

    collision gardien/gardien géré + pouvoir spéciaux de personnage géré

diff --git a/bin/exe b/bin/exe
index c35dee9..914871a 100755
Binary files a/bin/exe and b/bin/exe differ
diff --git a/include/Deplacement.h b/include/Deplacement.h
index ddcb86e..5b63e6c 100644
--- a/include/Deplacement.h
+++ b/include/Deplacement.h
@@ -1,6 +1,7 @@
 #ifndef __DEPLACEMENT__
 #define __DEPLACEMENT__
 
+#define VITESSE_NULLE 0.0
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
@@ -24,5 +25,4 @@ typedef struct position{
     /*float*/double x, y; /*position 2D*/
 }Position;
 
-void change_direction(Position *p, Direction direction);
 #endif
diff --git a/include/Gestion_terrain.h b/include/Gestion_terrain.h
index 45cc6f7..eb561e4 100644
--- a/include/Gestion_terrain.h
+++ b/include/Gestion_terrain.h
@@ -2,13 +2,15 @@
 #define __GESTION_TERRAIN__
 
 #include "Collision.h"
+#include "MLV/MLV_all.h"
+#include <unistd.h>
 
 int interaction_joueur_relique(Plateau *p);
 int interaction_joueur_tuile(Plateau *p);
-void deplacement_joueur(Plateau *p);
-
+void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_state *state, MLV_Keyboard_modifier *mod);
+void deplacement_gardien(Plateau *plateau);
 /*faire en sorte de recevoir les 2 gardiens qui veulent se rentrer dedans et les renvoyant dans des direction differente*/
-void interaction_gardien_gardien();
+void interaction_gardien_gardien(Plateau *p);
 
 /*retourne 1 si le joueur possede les 3 reliques et qu'il se trouve dans ses coord initiale, ou 0 sinon.*/
 int fin_de_jeu(Joueur const *j);
diff --git a/include/Moteur_de_jeu.h b/include/Moteur_de_jeu.h
index 435aaac..f8f3804 100644
--- a/include/Moteur_de_jeu.h
+++ b/include/Moteur_de_jeu.h
@@ -32,7 +32,7 @@ typedef struct tuile{
 }Tuile;
 
 typedef struct plateau{
-    int plateau [LARGEUR_PLATEAU][LONGEUR_PLATEAU];
+    int plateau[LARGEUR_PLATEAU][LONGEUR_PLATEAU];
     Joueur joueur;
     Gardien gardien[NB_GARDIEN];
     Relique relique[NB_RELIQUE];
diff --git a/makefile b/makefile
index 9ce3380..e863f05 100644
--- a/makefile
+++ b/makefile
@@ -46,4 +46,4 @@ $(DIR_OBJ)/Gestion_terrain.o: $(DIR_SRC)/Gestion_terrain.c $(DIR_HEADER)/Gestion
 #	$(CC) -c $< -o $(DIR_OBJ)/.o $(CFLAGS)
 
 clean:
-	rm -f $(OBJ) $(TARGET)
+	rm -f $(OBJ) $(DIR_BIN)/$(TARGET)
diff --git a/obj/Collision.o b/obj/Collision.o
index 3b2c7f7..9e9f7bb 100644
Binary files a/obj/Collision.o and b/obj/Collision.o differ
diff --git a/obj/Deplacement.o b/obj/Deplacement.o
index 822d285..af4479c 100644
Binary files a/obj/Deplacement.o and b/obj/Deplacement.o differ
diff --git a/obj/Gardien.o b/obj/Gardien.o
index d92205a..9968ddd 100644
Binary files a/obj/Gardien.o and b/obj/Gardien.o differ
diff --git a/obj/Gestion_terrain.o b/obj/Gestion_terrain.o
index daadec1..a978535 100644
Binary files a/obj/Gestion_terrain.o and b/obj/Gestion_terrain.o differ
diff --git a/obj/Joueur.o b/obj/Joueur.o
index 63a482e..0a5d60f 100644
Binary files a/obj/Joueur.o and b/obj/Joueur.o differ
diff --git a/obj/Moteur_de_jeu.o b/obj/Moteur_de_jeu.o
index 30380f8..ff1e91c 100644
Binary files a/obj/Moteur_de_jeu.o and b/obj/Moteur_de_jeu.o differ
diff --git a/obj/Moteur_graphique.o b/obj/Moteur_graphique.o
index 78ef870..48d1c15 100644
Binary files a/obj/Moteur_graphique.o and b/obj/Moteur_graphique.o differ
diff --git a/obj/Relique.o b/obj/Relique.o
index 8e5c597..4133ac9 100644
Binary files a/obj/Relique.o and b/obj/Relique.o differ
diff --git a/obj/main.o b/obj/main.o
index afa4a32..128cb8f 100644
Binary files a/obj/main.o and b/obj/main.o differ
diff --git a/src/Collision.c b/src/Collision.c
index dd20ad3..81726d6 100644
--- a/src/Collision.c
+++ b/src/Collision.c
@@ -181,7 +181,7 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
     distance_du_mur = distance_vers_mur(plateau, pos, dir);
     if(distance_du_mur > 1) return 0;
     switch(*dir){
-        case HAUT : if((int)(pos->y) - (*vitesse) > (int)(pos->y) + 0.5){
+        case HAUT : if((int)(pos->y)  > (int)(pos->y) + 0.5){
                         *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = DROITE;
@@ -189,7 +189,7 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
                     tmp_dir = GAUCHE;
                     collision_coin_haut_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case BAS :  if((int)(pos->y) + (*vitesse ) > (int)(pos->y) + 0.5){
+        case BAS :  if((int)(pos->y)  > (int)(pos->y) + 0.5){
                         *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = DROITE;
@@ -197,7 +197,7 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
                     tmp_dir = GAUCHE;
                     collision_coin_bas_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case GAUCHE : if((int)(pos->x) - (*vitesse ) > (int)(pos->x) + 0.5){
+        case GAUCHE : if((int)(pos->x)  > (int)(pos->x) + 0.5){
                         *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = BAS;
@@ -205,7 +205,7 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
                     tmp_dir = HAUT;
                     collision_coin_haut_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case DROITE : if((int)(pos->x) + (*vitesse ) > (int)(pos->x) + 0.5){
+        case DROITE : if((int)(pos->x)  > (int)(pos->x) + 0.5){
                         *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = BAS;
diff --git a/src/Gardien.c b/src/Gardien.c
index b4fbb9e..18db4b5 100644
--- a/src/Gardien.c
+++ b/src/Gardien.c
@@ -17,7 +17,7 @@ void change_vitesse_gardien(Etat_gardien *etat, double/*float*/ *vitesse){
     assert(NULL != vitesse);
     assert(NULL != etat);
     switch(*etat){
-        case MODE_NORMAL : *vitesse = (30.0 + rand() % (80 - 30)) / 100.0; break;
+        case MODE_NORMAL : *vitesse = (10.0 + rand() % (50 - 10)) / 100.0; break;
         case MODE_PANIQUE : *vitesse = 1.0; break;
         default : printf("mode non reconnu - vitesse nulle"); *vitesse = 0.0; break;
     }
@@ -31,9 +31,9 @@ void change_direction_(Direction *d){
     int pos;
     assert(NULL != d);
     do{
-        pos = rand() % 4;
-    }while(pos == *d);
-    *d = pos;
+        pos = rand();
+    }while((pos % 4) == *d);
+    *d = pos % 4;
 }
 
 /*configure le mode normal*/
diff --git a/src/Gestion_terrain.c b/src/Gestion_terrain.c
index 1425b86..3491ff9 100644
--- a/src/Gestion_terrain.c
+++ b/src/Gestion_terrain.c
@@ -47,23 +47,86 @@ int interaction_joueur_tuile(Plateau *p){
 }
 
 
-void interaction_gardien_gardien(){
+static int gardien_meme_position(Gardien *gardien_1, Gardien *gardien_2){
+    return ((int)gardien_1->pos.x == (int)gardien_2->pos.x && (int)gardien_1->pos.y == (int)gardien_2->pos.y) ? 1 : 0;
+}
 
-    return ;
+/*Fonction O.K*/
+void interaction_gardien_gardien(Plateau *plateau){
+    int i, j;
+    for(i = 0; i < NB_GARDIEN; ++i){
+        for(j = 0; j < NB_GARDIEN; ++j){
+            if(j != i && gardien_meme_position(&(plateau->gardien[i]), &(plateau->gardien[j]))){
+                change_direction_(&(plateau->gardien[i].direction));
+                change_vitesse_gardien(&(plateau->gardien[i].alerte), &(plateau->gardien[i].vitesse));
+
+                change_direction_(&(plateau->gardien[j].direction));
+                change_vitesse_gardien(&(plateau->gardien[j].alerte), &(plateau->gardien[j].vitesse));
+                /*printf("Interaction_gardien_gardien ==> wait(1sec)\n");
+                sleep(1);*/
+            }
+        }
+    }
 }
 
-/*interaction_joueur_mur ==> a gerer dans les deplacment du joueur*/
 
-void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_state *state){
+static void gestion_mode_acceleration_joueur(Joueur *joueur, MLV_Keyboard_modifier *mod){
+    assert(NULL != joueur);
+
+    if(MLV_shift_key_was_pressed(*mod) && joueur->mana > 2){
+        printf("Tu as pressé la touche shift\n");
+        joueur->mode = MODE_ACCELERE;
+        joueur->mana -= 2;
+    }
+    else if(MLV_get_keyboard_state(MLV_KEYBOARD_SPACE) == MLV_PRESSED/*MLV_shift_key_was_pressed(*mod)*/ && joueur->mana > 1){
+        printf("Tu as pressé la touche espace\n");
+        joueur->mode = MODE_INVISIBLE;
+        joueur->mana -= 1;
+    }
+    else{
+        joueur->mode = MODE_NORMAL;
+    }
+}
+
+static void gestion_mode_invisible_joueur(Joueur *joueur){
+    assert(NULL != joueur);
+
+    if(MLV_get_keyboard_state(MLV_KEYBOARD_SPACE) == MLV_PRESSED/*MLV_shift_key_was_pressed(*mod)*/ && joueur->mana > 1){
+        printf("Tu as pressé la touche espace\n");
+        joueur->mode = MODE_INVISIBLE;
+        joueur->mana -= 1;
+    }
+    else{
+        joueur->mode = MODE_NORMAL;
+    }
+}
+
+/*interaction_joueur_mur ==> a gerer dans les deplacment du joueur*/
+void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_state *state, MLV_Keyboard_modifier *mod){
+    
+    /*gestion_mode_invisible_joueur(&(plateau->joueur));*/
+    gestion_mode_acceleration_joueur(&(plateau->joueur), mod);
+    switch(plateau->joueur.mode){
+        case MODE_NORMAL: printf("MODE_NORMAL\n"); break;
+        case MODE_ACCELERE: printf("MODE_ACCELERE\n"); break;
+        case MODE_INVISIBLE: printf("MODE_INVISIBLE\n"); break;
+        default:break;
+    }
     if(*sym == MLV_KEYBOARD_z && *state == MLV_PRESSED){
-        plateau->joueur.direction = HAUT;
-        if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
+        plateau->joueur.direction = HAUT;/*
+        if(MLV_shift_key_was_pressed(*mod)){
+            printf("Tu as presser la touche shift-haut\n");
+        }*/
+        if(!collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse))){
             augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
             plateau->joueur.pos.y -= plateau->joueur.vitesse; /*printf("P-HAUT ");*/
         }
     }
     else if(*sym == MLV_KEYBOARD_s && *state == MLV_PRESSED){
-        plateau->joueur.direction = BAS;
+        plateau->joueur.direction = BAS;/*
+        if(MLV_shift_key_was_pressed(*mod)){
+            printf("Tu as presser la touche shift-bas\n");
+        }*/
         if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
             augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
             plateau->joueur.pos.y += plateau->joueur.vitesse; /*printf("P-BAS ");*/
@@ -71,14 +134,20 @@ void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_s
 
     }
     else if(*sym == MLV_KEYBOARD_q && *state == MLV_PRESSED){
-        plateau->joueur.direction = GAUCHE;
+        plateau->joueur.direction = GAUCHE;/*
+        if(MLV_shift_key_was_pressed(*mod)){
+            printf("Tu as presser la touche shift-gauche\n");
+        }*/
         if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
             augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
             plateau->joueur.pos.x -= plateau->joueur.vitesse; /*printf("P-GAUCHE ");*/
         }
     }
     else if(*sym == MLV_KEYBOARD_d && *state == MLV_PRESSED){
-        plateau->joueur.direction = DROITE;
+        plateau->joueur.direction = DROITE;/*
+        if(MLV_shift_key_was_pressed(*mod)){
+            printf("Tu as presser la touche shift-droite\n");
+        }*/
         if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
             augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
             plateau->joueur.pos.x += plateau->joueur.vitesse; /*printf("P-DROITE ");*/
@@ -92,29 +161,48 @@ void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_s
 
 static void effectue_deplacement_gardien(Gardien *g){
     switch(g->direction){
-        case HAUT : g->pos.y += g->vitesse; break;
-        case BAS : g->pos.y -= g->vitesse; break;
+        case HAUT : g->pos.y -= g->vitesse; break;
+        case BAS : g->pos.y += g->vitesse; break;
         case GAUCHE : g->pos.x -= g->vitesse; break;
         case DROITE : g->pos.x += g->vitesse; break;
         default : break;
     }
 }
-/*
-collision_contre_mur(Plateau const *plateau, Position *pos, Direction const *dir,double *vitesse)
-*/
+
+static void direction_opposer(Direction *d){
+    switch(*d){
+        case HAUT : *d = BAS; break;
+        case BAS : *d = HAUT; break;
+        case GAUCHE : *d = DROITE; break;
+        case DROITE : *d = GAUCHE; break;
+        default : break;
+    }
+}
+
 void deplacement_gardien(Plateau *plateau){
-    int i, tmp;
+    int i, tmp, flag;
+
     for(i = 0; i < NB_GARDIEN; ++i){
         tmp = rand() % 50;
-        if(collision_contre_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction), &(plateau->gardien[i].vitesse)) == 1 || tmp == 0){
-            plateau->gardien[i].vitesse = (-plateau->gardien[i].vitesse / 10);
+        flag = 0;
+        /*collision_contre_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction), &(plateau->gardien[i].vitesse)) == 1*/
+        /*!collision_contre_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction), &(plateau->gardien[i].vitesse))*/
+        /*distance_vers_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction)) > 1*/
+        if(!collision_contre_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction), &(plateau->gardien[i].vitesse))){
+            if(tmp == 0){
+                change_direction_(&(plateau->gardien[i].direction));
+                change_vitesse_gardien(&(plateau->gardien[i].alerte), &(plateau->gardien[i].vitesse));
+            }
             effectue_deplacement_gardien(&(plateau->gardien[i]));
-            change_vitesse_gardien(&(plateau->gardien[i].alerte), &(plateau->gardien[i].vitesse));
-            change_direction_(&(plateau->gardien[i].direction));
         }
         else{
+            if(flag == 0){
+                direction_opposer(&(plateau->gardien[i].direction));
+            }
+            change_vitesse_gardien(&(plateau->gardien[i].alerte), &(plateau->gardien[i].vitesse));
             effectue_deplacement_gardien(&(plateau->gardien[i]));
         }
+        /*printf("n°%d - dir = %d\n", i, plateau->gardien[i].direction);*/
     }
 }
 
diff --git a/src/Moteur_de_jeu.c b/src/Moteur_de_jeu.c
index 403734a..7928f6c 100644
--- a/src/Moteur_de_jeu.c
+++ b/src/Moteur_de_jeu.c
@@ -418,7 +418,7 @@ static void init_tuile(Plateau *game){
         game->tuile[i].mana = QUANTITE_MANA_TUILE;
         game->tuile[i].etat = NON_RECUPERER;
         while(1){
-            x = 1 + rand() % 57;
+            x = 1 + rand() % 56;
             y = 1 + rand() % 42;
             if(position_verification(x, y, game) == 1){
                 game->tuile[i].pos.x = x;
diff --git a/src/Moteur_graphique.c b/src/Moteur_graphique.c
index 16553b0..7bba30b 100644
--- a/src/Moteur_graphique.c
+++ b/src/Moteur_graphique.c
@@ -59,10 +59,10 @@ static void dessine_relique(Plateau const *p){
                                                         p->relique[i].pos.y * TAILLE_CASE,
                                                          TAILLE_CASE / 2, MLV_COLOR_LIGHT_BLUE);
                                break;
-            case RECUPERER : MLV_draw_filled_circle(p->relique[i].pos.x * TAILLE_CASE,
+            /*case RECUPERER : MLV_draw_filled_circle(p->relique[i].pos.x * TAILLE_CASE,
                                                         p->relique[i].pos.y * TAILLE_CASE,
                                                          TAILLE_CASE / 2, MLV_COLOR_PURPLE);
-                                break;
+                                break;*/
 
             default : break;
         }
diff --git a/src/main.c b/src/main.c
index eecf7c6..a9bbfd6 100644
--- a/src/main.c
+++ b/src/main.c
@@ -55,7 +55,7 @@ int main(int argc, const char * const argv[]){
         dessine_plateau_graphique(&plateau, LONGEUR_PLATEAU, LARGEUR_PLATEAU);
         event = MLV_get_event(&sym, &mod, NULL, NULL, NULL, NULL, NULL, NULL, &state);
         /*printf("state %d: \n", state);*/
-        deplacement_joueur(&plateau, &sym, &state);
+        deplacement_joueur(&plateau, &sym, &state, &mod);
         deplacement_gardien(&plateau);
         /*printf("vitesse:%f \n", plateau.joueur.vitesse);*/
         if(event == MLV_KEY){
@@ -67,6 +67,7 @@ int main(int argc, const char * const argv[]){
         /*Mecanisme de jeu et tt*/
         interaction_joueur_relique(&plateau);
         interaction_joueur_tuile(&plateau);
+        interaction_gardien_gardien(&(plateau));
         /*framerate*/
         clock_gettime(CLOCK_REALTIME, &new_time);
         frametime = new_time.tv_sec - end_time.tv_sec;
@@ -85,6 +86,11 @@ int main(int argc, const char * const argv[]){
     /*Chrono rapide du joueur - a ameliorer eventuellement ==> */
     printf("Durée de la partie = %.2fs\n",(double) ((end.tv_sec - start.tv_sec) + ((end.tv_nsec - start.tv_nsec) / 1.0E9)));
     printf("plateau taille = %d\n", (int)sizeof(plateau));
+    printf("joeur taille = %d\n", (int)sizeof(plateau.joueur));
+    printf("gard taille = %d\n", (int)sizeof(plateau.gardien));
+    printf("tuile taille = %d\n", (int)sizeof(plateau.tuile));
+    printf("relique taille = %d\n", (int)sizeof(plateau.relique));
+    printf("plateau dejue taille = %d\n", (int)sizeof(plateau.plateau));
     MLV_free_window();
     return 0;
 }

commit 8012c3c2c6c3925b1ec908b9b5deb70fcc66156f
Author: Prashath Sivayanama <prashath.sivayanama@etud.u-pem.fr>
Date:   Tue Jan 10 11:05:13 2023 +0100

    fonction deaplacement joueur et gardien ameliore

diff --git a/src/Collision.c b/src/Collision.c
index 8ea7384..dd20ad3 100644
--- a/src/Collision.c
+++ b/src/Collision.c
@@ -88,7 +88,7 @@ static void collision_coin_haut_gauche(Plateau const *plateau, Position *pos, do
     /*A CHANGER >>*/
     if(distance_du_mur > 1){return ;}
     switch(*dir_tmp){
-        case GAUCHE: if(pos->x < (int)(pos->x) + 0.5){
+        case GAUCHE: if(pos->x > (int)(pos->x) + 0.5){
                         if((int)(pos->y) + (*vitesse) > (int)(pos->y) + 1 - sqrt((1.0/4 - (pos->x - (int)(pos->x)) * (pos->x - (int)(pos->x))))){
                             *vitesse = 0.0;
                         }
@@ -182,7 +182,7 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
     if(distance_du_mur > 1) return 0;
     switch(*dir){
         case HAUT : if((int)(pos->y) - (*vitesse) > (int)(pos->y) + 0.5){
-                        *vitesse = 0.0;
+                        *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = DROITE;
                     collision_coin_haut_droite(plateau, pos, vitesse, &tmp_dir);
@@ -190,7 +190,7 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
                     collision_coin_haut_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
         case BAS :  if((int)(pos->y) + (*vitesse ) > (int)(pos->y) + 0.5){
-                        *vitesse = 0.0;
+                        *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = DROITE;
                     collision_coin_bas_droite(plateau, pos, vitesse, &tmp_dir);
@@ -198,7 +198,7 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
                     collision_coin_bas_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
         case GAUCHE : if((int)(pos->x) - (*vitesse ) > (int)(pos->x) + 0.5){
-                        *vitesse = 0.0;
+                        *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = BAS;
                     collision_coin_bas_gauche(plateau, pos, vitesse, &tmp_dir);
@@ -206,7 +206,7 @@ int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const
                     collision_coin_haut_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
         case DROITE : if((int)(pos->x) + (*vitesse ) > (int)(pos->x) + 0.5){
-                        *vitesse = 0.0;
+                        *vitesse = VITESSE_NULLE;
                     }
                     tmp_dir = BAS;
                     collision_coin_bas_droite(plateau, pos, vitesse, &tmp_dir);
diff --git a/src/Deplacement.c b/src/Deplacement.c
index 37a6d1e..688ad49 100644
--- a/src/Deplacement.c
+++ b/src/Deplacement.c
@@ -1,12 +1 @@
 #include "../include/Deplacement.h"
-
-void change_direction(Position *p, Direction direction){
-    assert(NULL != p);
-    switch(direction){
-        case HAUT : p->x -= 1; break;
-        case BAS : p->y -= 1; break;
-        case GAUCHE : p->x += 1; break;
-        case DROITE : p->y += 1; break;
-        default : break;
-    }
-}
diff --git a/src/Gestion_terrain.c b/src/Gestion_terrain.c
index 1caccd0..1425b86 100644
--- a/src/Gestion_terrain.c
+++ b/src/Gestion_terrain.c
@@ -53,11 +53,72 @@ void interaction_gardien_gardien(){
 }
 
 /*interaction_joueur_mur ==> a gerer dans les deplacment du joueur*/
-void deplacement_joueur(Plateau *p){
-    assert(NULL != p);
-    return ;
+
+void deplacement_joueur(Plateau *plateau, MLV_Keyboard_button *sym, MLV_Button_state *state){
+    if(*sym == MLV_KEYBOARD_z && *state == MLV_PRESSED){
+        plateau->joueur.direction = HAUT;
+        if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
+            augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
+            plateau->joueur.pos.y -= plateau->joueur.vitesse; /*printf("P-HAUT ");*/
+        }
+    }
+    else if(*sym == MLV_KEYBOARD_s && *state == MLV_PRESSED){
+        plateau->joueur.direction = BAS;
+        if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
+            augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
+            plateau->joueur.pos.y += plateau->joueur.vitesse; /*printf("P-BAS ");*/
+        }
+
+    }
+    else if(*sym == MLV_KEYBOARD_q && *state == MLV_PRESSED){
+        plateau->joueur.direction = GAUCHE;
+        if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
+            augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
+            plateau->joueur.pos.x -= plateau->joueur.vitesse; /*printf("P-GAUCHE ");*/
+        }
+    }
+    else if(*sym == MLV_KEYBOARD_d && *state == MLV_PRESSED){
+        plateau->joueur.direction = DROITE;
+        if(collision_contre_mur(plateau, &(plateau->joueur.pos), &(plateau->joueur.direction), &(plateau->joueur.vitesse)) == 0){
+            augmente_vitesse_joueur(&(plateau->joueur.mode), &(plateau->joueur.vitesse));
+            plateau->joueur.pos.x += plateau->joueur.vitesse; /*printf("P-DROITE ");*/
+        }
+    }
+    else{
+        plateau->joueur.vitesse = VITESSE_NULLE;
+    }
+}
+
+
+static void effectue_deplacement_gardien(Gardien *g){
+    switch(g->direction){
+        case HAUT : g->pos.y += g->vitesse; break;
+        case BAS : g->pos.y -= g->vitesse; break;
+        case GAUCHE : g->pos.x -= g->vitesse; break;
+        case DROITE : g->pos.x += g->vitesse; break;
+        default : break;
+    }
+}
+/*
+collision_contre_mur(Plateau const *plateau, Position *pos, Direction const *dir,double *vitesse)
+*/
+void deplacement_gardien(Plateau *plateau){
+    int i, tmp;
+    for(i = 0; i < NB_GARDIEN; ++i){
+        tmp = rand() % 50;
+        if(collision_contre_mur(plateau, &(plateau->gardien[i].pos), &(plateau->gardien[i].direction), &(plateau->gardien[i].vitesse)) == 1 || tmp == 0){
+            plateau->gardien[i].vitesse = (-plateau->gardien[i].vitesse / 10);
+            effectue_deplacement_gardien(&(plateau->gardien[i]));
+            change_vitesse_gardien(&(plateau->gardien[i].alerte), &(plateau->gardien[i].vitesse));
+            change_direction_(&(plateau->gardien[i].direction));
+        }
+        else{
+            effectue_deplacement_gardien(&(plateau->gardien[i]));
+        }
+    }
 }
 
+
 int fin_de_jeu(Joueur const *j){
     if((int)j->pos.x == COORD_FIN_DE_JEU_X &&
         (int)j->pos.y == COORD_FIN_DE_JEU_Y &&
diff --git a/src/main.c b/src/main.c
index 4b5591f..eecf7c6 100644
--- a/src/main.c
+++ b/src/main.c
@@ -4,7 +4,6 @@
 
 #include "../include/Gestion_terrain.h"
 #include "../include/Moteur_graphique.h"
-#include "MLV/MLV_all.h"
 #include <time.h>
 
 static void aff_plat(Plateau *plat){
@@ -25,28 +24,6 @@ static void aff_plat(Plateau *plat){
     printf("\n\n");
 }
 
-/*Ancienne version */
-/*
-if(MLV_get_keyboard_state(MLV_KEYBOARD_z) == MLV_PRESSED){
-    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-    plateau.joueur.pos.y -= plateau.joueur.vitesse; printf("P-HAUT ");
-}
-else if(MLV_get_keyboard_state(MLV_KEYBOARD_s) == MLV_PRESSED){
-    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-    plateau.joueur.pos.y += plateau.joueur.vitesse; printf("P-BAS ");
-}
-else if(MLV_get_keyboard_state(MLV_KEYBOARD_q) == MLV_PRESSED){
-    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-    plateau.joueur.pos.x -= plateau.joueur.vitesse; printf("P-GAUCHE ");
-}
-else if(MLV_get_keyboard_state(MLV_KEYBOARD_d) == MLV_PRESSED){
-    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-    plateau.joueur.pos.x += plateau.joueur.vitesse; printf("P-DROITE ");
-}
-else{
-    plateau.joueur.vitesse = 0;
-}
-*/
 
 
 int main(int argc, const char * const argv[]){
@@ -69,115 +46,37 @@ int main(int argc, const char * const argv[]){
     srand(time(NULL));
     MLV_create_window("ko", "ka", LONGUEUR_FENETRE, LARGEUR_FENETRE);
     create_map(&plateau);
-    printf("%f - %f\n", plateau.gardien[0].pos.x, plateau.gardien[0].pos.y);
-    printf("%f - %f\n", plateau.gardien[1].pos.x, plateau.gardien[1].pos.y);
-    printf("%f - %f\n", plateau.gardien[2].pos.x, plateau.gardien[2].pos.y);
-    printf("%f - %f\n", plateau.gardien[3].pos.x, plateau.gardien[3].pos.y);
-    printf("%f - %f\n", plateau.gardien[4].pos.x, plateau.gardien[4].pos.y);
     /*aff_plat(&plateau);*/
 
     clock_gettime(CLOCK_REALTIME, &start);
-    plateau.joueur.direction = HAUT;
-    printf("H->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
-    plateau.joueur.direction = BAS;
-    printf("B->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
-    plateau.joueur.direction = GAUCHE;
-    printf("G->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
-    plateau.joueur.direction = DROITE;
-    printf("D->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
     while(fin_de_partie){
         /*CALCUL_DE_TEMPS*/
         clock_gettime(CLOCK_REALTIME, &end_time);
         dessine_plateau_graphique(&plateau, LONGEUR_PLATEAU, LARGEUR_PLATEAU);
-
         event = MLV_get_event(&sym, &mod, NULL, NULL, NULL, NULL, NULL, NULL, &state);
-        printf("state %d: \n", state);
-
-        if(sym == MLV_KEYBOARD_z && state == MLV_PRESSED){
-            plateau.joueur.direction = HAUT;
-            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
-            }
-            else{
-                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-                plateau.joueur.pos.y -= plateau.joueur.vitesse; printf("P-HAUT ");
-            }
-        }
-        else if(sym == MLV_KEYBOARD_s && state == MLV_PRESSED){
-            plateau.joueur.direction = BAS;
-            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
-            }
-            else{
-                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-                plateau.joueur.pos.y += plateau.joueur.vitesse; printf("P-BAS ");
-            }
-
-        }
-        else if(sym == MLV_KEYBOARD_q && state == MLV_PRESSED){
-            plateau.joueur.direction = GAUCHE;
-            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
-            }
-            else{
-                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-                plateau.joueur.pos.x -= plateau.joueur.vitesse; printf("P-GAUCHE ");
-            }
-        }
-        else if(sym == MLV_KEYBOARD_d && state == MLV_PRESSED){
-            plateau.joueur.direction = DROITE;
-            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
-            }
-            else{
-                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
-                plateau.joueur.pos.x += plateau.joueur.vitesse; printf("P-DROITE ");
-            }
-        }
-        else{
-            plateau.joueur.vitesse = 0;
-        }
-        /*
-        switch(plateau.joueur.direction){
-            case HAUT :printf("H : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
-            case BAS :printf("B : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
-            case DROITE:printf("D : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
-            case GAUCHE:printf("G : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
-            default :break;
-        }
-        */
-
-        printf("vitesse:%f \n", plateau.joueur.vitesse);
+        /*printf("state %d: \n", state);*/
+        deplacement_joueur(&plateau, &sym, &state);
+        deplacement_gardien(&plateau);
+        /*printf("vitesse:%f \n", plateau.joueur.vitesse);*/
         if(event == MLV_KEY){
-            /*if(sym == MLV_KEYBOARD_z && state == MLV_PRESSED){
-                plateau.joueur.pos.y -= 1; printf("P-HAUT ");
-            }
-            else if(sym == MLV_KEYBOARD_s && state == MLV_PRESSED){
-                plateau.joueur.pos.y += 1; printf("P-BAS ");
-            }
-            else if(sym == MLV_KEYBOARD_q && state == MLV_PRESSED){
-                plateau.joueur.pos.x -= 1; printf("P-GAUCHE ");
-            }
-            else if(sym == MLV_KEYBOARD_d && state == MLV_PRESSED){
-                plateau.joueur.pos.x += 1; printf("P-DROITE ");
-            }*/
             if(sym == MLV_KEYBOARD_t){
                 aff_plat(&plateau);
                 break;
             }
         }
-
         /*Mecanisme de jeu et tt*/
         interaction_joueur_relique(&plateau);
         interaction_joueur_tuile(&plateau);
-        /* ... */
+        /*framerate*/
         clock_gettime(CLOCK_REALTIME, &new_time);
         frametime = new_time.tv_sec - end_time.tv_sec;
         frametime += (new_time.tv_sec - end_time.tv_sec) / 1.0E9;
         extratime = (1.0 / 60) - frametime;
-        /*
-        printf("(1.0/60.0) = %f\nextratime : %f\nframetime : %f\n",(1.0 / 60.0), extratime, frametime);
-        */
-
+        /*printf("(1.0/60.0) = %f\nextratime : %f\nframetime : %f\n",(1.0 / 60.0), extratime, frametime);*/
         if(extratime > 0){
             MLV_wait_milliseconds((int)(extratime * 1000));
         }
+        /*fin de partie*/
         if(fin_de_jeu(&(plateau.joueur))){
             fin_de_partie = 0;
         }
@@ -185,7 +84,7 @@ int main(int argc, const char * const argv[]){
     clock_gettime(CLOCK_REALTIME, &end);
     /*Chrono rapide du joueur - a ameliorer eventuellement ==> */
     printf("Durée de la partie = %.2fs\n",(double) ((end.tv_sec - start.tv_sec) + ((end.tv_nsec - start.tv_nsec) / 1.0E9)));
-
+    printf("plateau taille = %d\n", (int)sizeof(plateau));
     MLV_free_window();
     return 0;
 }

commit 0f98a6fe39a41edc10f49411b0696b2e1119b022
Author: Prashath Sivayanama <prashath.sivayanama@etud.u-pem.fr>
Date:   Fri Jan 6 16:17:58 2023 +0100

    correction erreur

diff --git a/bin/exe b/bin/exe
index c15c8cc..c35dee9 100755
Binary files a/bin/exe and b/bin/exe differ
diff --git a/include/Gardien.h b/include/Gardien.h
index cf21739..0e8e623 100644
--- a/include/Gardien.h
+++ b/include/Gardien.h
@@ -24,11 +24,11 @@ typedef struct gardien {
     int distance_detection;
     Direction direction;
     Position pos;
-    float vitesse;
+    double/*float*/ vitesse;
 }Gardien;
 
 
-void change_vitesse_gardien(Etat_gardien *etat, float *vitesse);
+void change_vitesse_gardien(Etat_gardien *etat, double/*float*/ *vitesse);
 void change_direction_(Direction *d);
 void config_gardien_mode_normal(Gardien *g);
 void config_gardien_mode_panique(Gardien *g);
diff --git a/include/Moteur_de_jeu.h b/include/Moteur_de_jeu.h
index 11a9d4e..435aaac 100644
--- a/include/Moteur_de_jeu.h
+++ b/include/Moteur_de_jeu.h
@@ -8,19 +8,30 @@
 
 #define LARGEUR_PLATEAU 45
 #define LONGEUR_PLATEAU 60
+#define DISTANCE_MIN_JOUEUR_GARDIEN_OBJ 20
 #define NB_RELIQUE 3
 #define NB_GARDIEN 5
 #define NB_TUILE 20
+#define QUANTITE_MANA_TUILE 60
 #define minside 9
 
+typedef enum element_de_jeu{
+    VIDE,
+    MUR,
+    GARDIEN,
+    RELIQUE,
+    JOUEUR,
+    TUILE
+}Element_de_jeu;
 
-typedef struct {
+
+typedef struct tuile{
     Etat_objet etat;
     Position_obj pos;
     int mana;/*60*/
 }Tuile;
 
-typedef struct {
+typedef struct plateau{
     int plateau [LARGEUR_PLATEAU][LONGEUR_PLATEAU];
     Joueur joueur;
     Gardien gardien[NB_GARDIEN];
diff --git a/obj/Collision.o b/obj/Collision.o
index 8ce31e0..3b2c7f7 100644
Binary files a/obj/Collision.o and b/obj/Collision.o differ
diff --git a/obj/Deplacement.o b/obj/Deplacement.o
index a69d4dd..822d285 100644
Binary files a/obj/Deplacement.o and b/obj/Deplacement.o differ
diff --git a/obj/Gardien.o b/obj/Gardien.o
index c3378fc..d92205a 100644
Binary files a/obj/Gardien.o and b/obj/Gardien.o differ
diff --git a/obj/Gestion_terrain.o b/obj/Gestion_terrain.o
index a5b4263..daadec1 100644
Binary files a/obj/Gestion_terrain.o and b/obj/Gestion_terrain.o differ
diff --git a/obj/Joueur.o b/obj/Joueur.o
index 0a5d60f..63a482e 100644
Binary files a/obj/Joueur.o and b/obj/Joueur.o differ
diff --git a/obj/Moteur_de_jeu.o b/obj/Moteur_de_jeu.o
index bef860c..30380f8 100644
Binary files a/obj/Moteur_de_jeu.o and b/obj/Moteur_de_jeu.o differ
diff --git a/obj/Moteur_graphique.o b/obj/Moteur_graphique.o
index 4cd2f3e..78ef870 100644
Binary files a/obj/Moteur_graphique.o and b/obj/Moteur_graphique.o differ
diff --git a/obj/Relique.o b/obj/Relique.o
index 4133ac9..8e5c597 100644
Binary files a/obj/Relique.o and b/obj/Relique.o differ
diff --git a/obj/main.o b/obj/main.o
index c09c8ae..afa4a32 100644
Binary files a/obj/main.o and b/obj/main.o differ
diff --git a/src/Gardien.c b/src/Gardien.c
index a1f8c62..b4fbb9e 100644
--- a/src/Gardien.c
+++ b/src/Gardien.c
@@ -13,7 +13,7 @@ mode panique si relique disparu
 
 
 /*attribue une vitesse aleatoire*/
-void change_vitesse_gardien(Etat_gardien *etat, float *vitesse){
+void change_vitesse_gardien(Etat_gardien *etat, double/*float*/ *vitesse){
     assert(NULL != vitesse);
     assert(NULL != etat);
     switch(*etat){
@@ -68,7 +68,6 @@ void initalise_gardien(Gardien *g){
     printf("(champs à ingnoré)-> direction initial = %d\n", g->direction);
     /*init_coord_aleatoire(&(g->pos));*/
     config_gardien_mode_normal(g);
-
 }
 
 
diff --git a/src/Moteur_de_jeu.c b/src/Moteur_de_jeu.c
index da39e21..403734a 100644
--- a/src/Moteur_de_jeu.c
+++ b/src/Moteur_de_jeu.c
@@ -28,141 +28,215 @@ void init_coord_aleatoire(Position *pos){
 
 */
 
-static void make_wall_on_board(int i,int j ,int nb,int direction ,Plateau * game){
+/*Fabrique le côté des murs*/
+static void make_wall_on_board(int i, int j, int nb, int direction, Plateau *game){
     /*printf("Poser a la position x %d et y %d avec un nb de %d\n",i,j,nb);*/
     int cpt;
-    if(nb==0){
+
+    assert(NULL != game);
+
+    if(nb == 0){
         return;
     }
-    if(direction ==0){
-        for(cpt=1;cpt<nb+1;cpt++){
-            game->plateau[i][j+cpt]=1;
+    if(direction == 0){
+        for(cpt = 1; cpt < nb + 1; cpt++){
+            game->plateau[i][j + cpt] = MUR;
         }
     }
-    if(direction ==1){
-        for(cpt=1;cpt<nb+1;cpt++){
-            game->plateau[i][j-cpt]=1;
+    if(direction == 1){
+        for(cpt = 1; cpt < nb + 1; cpt++){
+            game->plateau[i][j - cpt] = MUR;
         }
     }
-    if(direction ==2){
-        for(cpt=1;cpt<nb+1;cpt++){
-            game->plateau[i+cpt][j]=1;
+    if(direction == 2){
+        for(cpt = 1; cpt < nb + 1; cpt++){
+            game->plateau[i + cpt][j] = MUR;
         }
     }
-    if(direction ==3){
-        for(cpt=1;cpt<nb+1;cpt++){
-            game->plateau[i-cpt][j]=1;
+    if(direction == 3){
+        for(cpt = 1; cpt < nb + 1; cpt++){
+            game->plateau[i-cpt][j] = MUR;
         }
     }
 }
 
-static int verification_case(int i ,int j ,Plateau game,int direction ){
-    int x,y;
-    if(i>8 && direction !=3 &&direction !=2){
-        for(x =1;x<minside;x++){
-            if(game.plateau[i-x][j]==1){
-           /*printf(" i = %d j = %d direction = %d 1\n",i,j,direction);*/return 0;}
-        }
+/**/
+static int verification_case(int i, int j, Plateau const *game, int direction){
+    int x, y;
+
+    assert(NULL != game);
 
+    if(i > minside - 1 && direction != 3 && direction != 2){
+        for(x = 1; x < minside; x++){
+            if(game->plateau[i - x][j] == MUR){
+                /*printf(" i = %d j = %d direction = %d 1\n", i, j, direction);*/
+                return 0;
+            }
+        }
     }
-    if(i<LARGEUR_PLATEAU-10 && direction !=2&&direction !=3){
-        for ( y = 1; y < minside; y++){
-            if(game.plateau[i+y][j]==1){
-            /*printf(" i = %d j = %d direction = %d 2\n",i,j,direction);*/return 0;}
+    if(i < LARGEUR_PLATEAU - 10 && direction != 2 && direction != 3){
+        for(y = 1; y < minside; y++){
+            if(game->plateau[i + y][j] == MUR){
+                /*printf(" i = %d j = %d direction = %d 2\n", i, j, direction);*/
+                return 0;
+            }
         }
     }
-    if(j<LONGEUR_PLATEAU-10 && direction !=0 && direction !=1 ){
-        for(x =1 ;x<minside;x++){
-            if(game.plateau[i][j+x]==1){/*printf("i = %d j = %d direction = %d 3\n",i,j,direction);*/return 0;}
+    if(j < LONGEUR_PLATEAU - 10 && direction != 0 && direction != 1){
+        for(x = 1; x < minside; x++){
+            if(game->plateau[i][j + x] == MUR){
+                /*printf("i = %d j = %d direction = %d 3\n",i,j,direction);*/
+                return 0;
+            }
         }
     }
-    if(j>8 && direction !=1 && direction !=0){
-        for(y =1;y< minside;y++){
-            if(game.plateau[i][j-y]==1){/*printf(" i = %d j = %d direction = %d 4\n",i,j,direction);*/return 0;}
+    if(j > minside - 1 && direction != 1 && direction != 0){
+        for(y = 1; y < minside; y++){
+            if(game->plateau[i][j - y] == MUR){
+                /*printf(" i = %d j = %d direction = %d 4\n",i,j,direction);*/
+                return 0;
+            }
         }
     }
     return 1;
-
 }
 
 
-static int lenght_of_wall_verification(int x,int y,Plateau game,int direction){
-    int i, j, cpt = 0;
-   /*printf("lenght_of_wall_verification x = %d y = %d direction =%d \n",x,y,direction);*/
+static int lenght_of_wall_verification(int x, int y, Plateau const *game, int direction){
+    int i, j, cpt;
+
+    assert(NULL != game);
+
+    cpt = 0;
+    /*printf("lenght_of_wall_verification x = %d y = %d direction =%d \n",x,y,direction);*/
     if(direction == 0 && y < LONGEUR_PLATEAU - 1){
         for(j = y + 1; j < LONGEUR_PLATEAU; ++j){
-            if(game.plateau[x][j]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
-            if(verification_case(x, j, game, direction) == 0){/*printf("lenght_of_wall_verification return 0\n");*/return 0;}
+            if(game->plateau[x][j] == 1){
+                /*printf("lenght_of_wall_verification return %d \n",cpt);*/
+                return cpt;
+            }
+            if(verification_case(x, j, game, direction) == 0){
+                /*printf("lenght_of_wall_verification return 0\n");*/
+                return 0;
+            }
             ++cpt;
         }
     }
     else if(direction == 1 && y > 0){
         for(j = y - 1; j >= 0; --j){
-            if(game.plateau[x][j] == 1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
-            if(verification_case(x, j, game, direction) == 0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+            if(game->plateau[x][j] == 1){
+                /*printf("lenght_of_wall_verification return %d \n",cpt);*/
+                return cpt;
+            }
+            if(verification_case(x, j, game, direction) == 0){
+                /*printf("lenght_of_wall_verification return 0 \n");*/
+                return 0;
+            }
             ++cpt;
         }
     }
     else if(direction == 3 && x > 0){
-        for ( i = x-1; i>=0; i--){
-           if(game.plateau[i][y]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
-            if(verification_case(i,y,game,direction)==0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+        for(i = x - 1; i >= 0; i--){
+            if(game->plateau[i][y] == 1){
+                /*printf("lenght_of_wall_verification return %d \n",cpt);*/
+                return cpt;
+            }
+            if(verification_case(i, y, game, direction) == 0){
+                /*printf("lenght_of_wall_verification return 0 \n");*/
+                return 0;
+            }
             cpt++;
         }
     }
-    else if(direction == 2 && x < LARGEUR_PLATEAU-1){
-        for ( i = x+1; i<LARGEUR_PLATEAU; i++){
-            if(game.plateau[i][y]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
-            if(verification_case(i,y,game,direction)==0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+    else if(direction == 2 && x < LARGEUR_PLATEAU - 1){
+        for(i = x + 1; i < LARGEUR_PLATEAU; i++){
+            if(game->plateau[i][y] == MUR){
+                /*printf("lenght_of_wall_verification return %d \n",cpt);*/
+                return cpt;
+            }
+            if(verification_case(i, y, game, direction) == 0){
+                /*printf("lenght_of_wall_verification return 0 \n");*/
+                return 0;
+            }
             cpt++;
         }
     }
     /*printf("return 0\n");*/
     return 0;
-
 }
 
-static int line_of_wall_respected(int x ,int y ,Plateau game,int direction){
-    int i,j,cpt=0;
+static int line_of_wall_respected(int x, int y, Plateau const *game, int direction){
+    int i, j, cpt;
+
+    assert(NULL != game);
+
+    i = 0, j = 0, cpt = 0;
+
     /*printf(" line_of_wall_respected avec x %d et y %d et direction %d \n",x,y,direction);*/
-    if((direction == 0 || direction ==1)){
-        if((direction==0&& y>LONGEUR_PLATEAU-1) ||(direction==1&& y<1)){/*printf("line_of_wall_respected return 1 \n");*/return 0;}
-        for(i = x ; i<LARGEUR_PLATEAU;i++){
-            if(direction == 0 && game.plateau[i][y+1]==1){ /*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside +1 ? 1:0;}
-            if(direction == 1  && game.plateau[i][y-1]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
+    if((direction == 0 || direction == 1)){
+        if((direction == 0 && y > LONGEUR_PLATEAU - 1) || (direction == 1 && y < 1)){
+            /*printf("line_of_wall_respected return 1 \n");*/
+            return 0;
+        }
+        for(i = x; i < LARGEUR_PLATEAU; i++){
+            if(direction == 0 && game->plateau[i][y + 1] == MUR){
+                /*printf("line_of_wall_respected return %d \n",cpt);*/
+                return (cpt >= minside + 1) ? 1 : 0;
+            }
+            if(direction == 1 && game->plateau[i][y - 1] == MUR){
+                /*printf("line_of_wall_respected return %d \n",cpt);*/
+                return (cpt >= minside + 1) ? 1 : 0;
+            }
             cpt++;
         }
     }
-    if((direction == 2 || direction ==3)){
-        if((direction ==2 && x > LARGEUR_PLATEAU-1)||(direction ==3 && x < 1)){/*printf("line_of_wall_respected return 0\n");*/return 0;}
-        for(j = y;j<LONGEUR_PLATEAU;j++){
-            if(direction ==2 && game.plateau[x+1][j]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
-            if(direction==3 && game.plateau[x-1][j]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
+    if((direction == 2 || direction == 3)){
+        if((direction == 2 && x > LARGEUR_PLATEAU - 1) || (direction == 3 && x < 1)){
+            /*printf("line_of_wall_respected return 0\n");*/
+            return 0;
+        }
+        for(j = y; j < LONGEUR_PLATEAU; j++){
+            if(direction == 2 && game->plateau[x + 1][j] == MUR){
+                /*printf("line_of_wall_respected return %d \n",cpt);*/
+                return (cpt >= minside + 1) ? 1 : 0;
+            }
+            if(direction == 3 && game->plateau[x - 1][j] == MUR){
+                /*printf("line_of_wall_respected return %d \n",cpt);*/
+                return (cpt >= minside + 1) ? 1 : 0;
+            }
             cpt++;
         }
     }
     /*printf("line_of_wall_respected return %d \n",cpt);*/
-    return cpt>= minside ? 1:0;
+    return (cpt >= minside) ? 1 : 0;
 }
 
 
-static void generation_wall_on_game_by_line(double line,int direction,int nb,Plateau * game){
+static void generation_wall_on_game_by_line(double line, int direction, int nb, Plateau *game){
     /*printf("nb = %d \n",nb);*/
-    int i,j,cpt;
-    if(direction ==0|| direction==1){
-        for ( j = 0; j < LONGEUR_PLATEAU; j++){
-            for ( i = 0; i < LARGEUR_PLATEAU; i++){
-                if(game->plateau[i][j]==1){cpt++;}
-                if (game->plateau[i][j]==0){cpt=0;}
+    int i, j, cpt;
+
+    assert(NULL != game);
+
+    cpt = i = j = 0;
+    if(direction == 0 || direction == 1){
+        for(j = 0; j < LONGEUR_PLATEAU; j++){
+            for(i = 0; i < LARGEUR_PLATEAU; i++){
+                if(game->plateau[i][j] == MUR){
+                    cpt++;
+                }
+                if(game->plateau[i][j] == VIDE){
+                    cpt = 0;
+                }
                 /*if(line_of_wall_respected(i,j,(*game),direction)==-1){break;}*/
-                if(cpt>=(int)line && line_of_wall_respected(i,j,(*game),direction)==1 ){
+                if(cpt >= (int)line && line_of_wall_respected(i, j, game, direction) == 1){
                     /*printf("Le cpt de la fonction principale = %d \n",cpt);*/
                     /*printf("On rentre dans la verification pricipale\n");*/
-                    if(lenght_of_wall_verification(i,j,(*game),direction)>6){
-                        printf(" accepte avec i = %d et j = %d \n",i,j);
-                        if (rand()%(nb)==0){
-                           printf(" rand   accepte\n");
-                            make_wall_on_board(i,j,lenght_of_wall_verification(i,j,(*game),direction)-3,direction,game);
+                    if(lenght_of_wall_verification(i, j, game, direction) > 6){
+                        printf(" accepte avec i = %d et j = %d \n", i, j);
+                        if(rand() % nb == 0){
+                            printf(" rand   accepte\n");
+                            make_wall_on_board(i, j, lenght_of_wall_verification(i, j, game, direction) - 3, direction, game);
                             return ;
                         }
                     }
@@ -170,21 +244,24 @@ static void generation_wall_on_game_by_line(double line,int direction,int nb,Pla
             }
         }
     }
-    if(direction ==2|| direction==3){
-        for ( i = 0; i < LARGEUR_PLATEAU; i++){
-            for ( j = 0; j< LONGEUR_PLATEAU; j++){
-                if(game->plateau[i][j]==1){cpt++;}
-                if (game->plateau[i][j]==0){ cpt=0;}
+    if(direction == 2 || direction == 3){
+        for(i = 0; i < LARGEUR_PLATEAU; i++){
+            for(j = 0; j < LONGEUR_PLATEAU; j++){
+                if(game->plateau[i][j] == MUR){
+                    cpt++;
+                }
+                if(game->plateau[i][j] == VIDE){
+                    cpt = 0;
+                }
                 /*if(line_of_wall_respected(i,j,(*game),direction)==-1){break;}*/
-                if(cpt>=(int)line && line_of_wall_respected(i,j,(*game),direction)==1 ){
+                if(cpt >= (int)line && line_of_wall_respected(i, j, game, direction) ==1){
                     /*printf("Le cpt de la fonction principale = %d \n",cpt);*/
                     /*printf("On rentre dans la verification pricipale\n");*/
-                    if(lenght_of_wall_verification(i,j,(*game),direction)>6){
-                        printf(" accepte avec i = %d et j = %d \n",i,j);
-
-                        if (rand()%(nb)==0){
+                    if(lenght_of_wall_verification(i, j, game, direction) > 6){
+                        printf(" accepte avec i = %d et j = %d \n", i, j);
+                        if(rand() % nb == 0){
                             printf(" rand   accepte\n");
-                            make_wall_on_board(i,j,lenght_of_wall_verification(i,j,(*game),direction)-3,direction,game);
+                            make_wall_on_board(i, j, lenght_of_wall_verification(i, j, game, direction) - 3, direction, game);
                             return ;
                         }
                     }
@@ -192,17 +269,23 @@ static void generation_wall_on_game_by_line(double line,int direction,int nb,Pla
             }
         }
     }
-
 }
 
 static void generation_lenght_wall(double height, double lenght, int nb, Plateau *game){
     double x, y, line;
     int mur;
+
+    assert(NULL != game);
+
     x = height < lenght ? lenght : height;
     y = height < lenght ? height : lenght;
-    if(x < (2 * minside + 1)){return ;}
+    if(x < (2 * minside + 1)){
+        return ;
+    }
     if(x < (4 * minside)){
-        if(rand() % 2 == 0){return ;}
+        if(rand() % 2 == 0){
+            return ;
+        }
     }
     line = x / 2;
     mur = rand() % 4 ;/* 0 droite, 1 gauche , 2 bas ,3 haut*/
@@ -214,87 +297,108 @@ static void generation_lenght_wall(double height, double lenght, int nb, Plateau
 
 
 static void generation_wall_ext(Plateau *game){
-    int i,j;
-    for (i= 0; i < LARGEUR_PLATEAU; i++)
-    {
-        for(j =0;j<LONGEUR_PLATEAU;j++){
-            if(i == 0 || i ==44||j == 0 || j == 59){
-                game->plateau[i][j] = 1;
+    int i, j;
+
+    assert(NULL != game);
+
+    for(i = 0; i < LARGEUR_PLATEAU; i++){
+        for(j = 0; j < LONGEUR_PLATEAU; j++){
+            if(i == 0 || i == LARGEUR_PLATEAU - 1 || j == 0 || j == LONGEUR_PLATEAU - 1){
+                game->plateau[i][j] = MUR;
             }
             else{
-                game->plateau[i][j] = 0;
+                game->plateau[i][j] = VIDE;
             }
         }
     }
+}
 
 
-}
 
+static int not_on_openside(int x, int y, Plateau const *game){
+    int i, hor, vertic;
 
+    assert(NULL != game);
 
-static int not_on_openside(int x,int y , Plateau game){
-    int i ,hor=0,vertic=0;
-    for(i=1;i<=3;i++){
-        if(game.plateau[x-i][y]==1){
-            hor+=1;
+    i = 0, hor = 0, vertic = 0;
+    printf("-->>>x = %d:y = %d\n", x, y);
+    for(i = 1; i <= 3; i++){
+        if(game->plateau[x - i][y] == MUR){
+            hor++;
             break;
         }
     }
-    for(i=1;i<=3;i++){
-        if(game.plateau[x+i][y]==1){
-            hor+=1;
+    for(i = 1; i <= 3; i++){
+        if(game->plateau[x + i][y] == MUR){
+            hor++;
             break;
         }
     }
-    if(hor==2){return 0;}
-    for(i=1;i<=3;i++){
-        if(game.plateau[x][y-i]==1){
-            vertic+=1;
+    for(i = 1; i <= 3; i++){
+        if(game->plateau[x][y - i] == MUR){
+            vertic++;
             break;
         }
     }
-     for(i=1;i<=3;i++){
-        if(game.plateau[x][y+i]==1){
-            vertic+=1;
+    for(i = 1; i <= 3; i++){
+        if(game->plateau[x][y + i] == MUR){
+            vertic++;
             break;
         }
     }
-    if(vertic==2){return 0;}
+    if(vertic == 2 || hor == 2){
+        return 0;
+    }
     return 1;
-
 }
-static int position_verification(int x,int y ,Plateau game){
-    if(game.plateau[x][y] == 0 && sqrt((1-x)*(1-x)+(1-y)*(1-y)) >= 20 && not_on_openside(x,y,game)==1){
+
+
+static int position_verification(int x, int y, Plateau const *game){
+    int value;
+
+    assert(NULL != game);
+    printf("|||||||||\n\nx = %d - y = %d||||||||||||||||||||\n\n", x, y);
+    value = (int)(sqrt((1 - x)*(1 - x) + (1 - y)*(1 - y)));
+    if(game->plateau[x][y] == VIDE && value >= DISTANCE_MIN_JOUEUR_GARDIEN_OBJ && not_on_openside(x, y, game) == 1){
         return 1;
     }
     return 0;
 }
-static void init_Gardien(Plateau * game){
-    int i,x,y;
-    for ( i = 0; i < NB_GARDIEN; i++)
-    {
-        initalise_gardien(&game->gardien[i]);
+
+
+static void init_Gardien(Plateau *game){
+    int i, x, y;
+
+    assert(NULL != game);
+
+    x = 0, y = 0;
+    for(i = 0; i < NB_GARDIEN; i++){
+        initalise_gardien(&(game->gardien[i]));
         while(1){
-            x = rand()%57+1;
-            y=rand()%42+1;
-            if(position_verification(x,y,*game)==1){
+            x = 1 + rand() % 57;
+            y = 1 + rand() % 42;
+            if(position_verification(x, y, game) == 1){
                 game->gardien[i].pos.x = x;
                 game->gardien[i].pos.y = y;
                 break;
             }
         }
     }
-
 }
 
-static void init_Relique(Plateau * game){
-    int i,x,y;
-    for(i=0;i<NB_RELIQUE;i++){
-        initialise_relique(&game->relique[i]);
+static void init_Relique(Plateau *game){
+    int i, x, y;
+
+    assert(NULL != game);
+
+    x = 0, y = 0;
+    for(i = 0; i < NB_RELIQUE; i++){
+        printf("relique");
+        initialise_relique(&(game->relique[i]));
         while(1){
-            x = rand()%57+1;
-            y=rand()%42+1;
-            if(position_verification(x,y,*game)==1){
+            x = 1 + rand() % 57;
+            y = 1 + rand() % 42;
+            if(position_verification(x, y, game) == 1){
                 game->relique[i].pos.x = x;
                 game->relique[i].pos.y = y;
                 break;
@@ -303,16 +407,20 @@ static void init_Relique(Plateau * game){
     }
 }
 
-static void init_tuile(Plateau * game){
+static void init_tuile(Plateau *game){
+    int i, x, y;
+
+    assert(NULL != game);
 
-    int i ,x,y;
-    for(i=0;i<NB_TUILE;i++){
-        game->tuile[i].mana = 60;
+    x = 0, y = 0;
+    for(i = 0; i < NB_TUILE; i++){
+        printf("tuile");
+        game->tuile[i].mana = QUANTITE_MANA_TUILE;
         game->tuile[i].etat = NON_RECUPERER;
         while(1){
             x = 1 + rand() % 57;
             y = 1 + rand() % 42;
-            if(position_verification(x, y, *game) == 1){
+            if(position_verification(x, y, game) == 1){
                 game->tuile[i].pos.x = x;
                 game->tuile[i].pos.y = y;
                 break;
@@ -323,61 +431,70 @@ static void init_tuile(Plateau * game){
 
 static void init_plateau(Plateau *p){
     int i, j;
+
+    assert(NULL != p);
+
     for(i = 0; i < LARGEUR_PLATEAU; ++i){
         for(j = 0; j < LONGEUR_PLATEAU; ++j){
-            p->plateau[i][j] = 0;
+            p->plateau[i][j] = VIDE;
         }
     }
 }
 
 
-static void init_objects_in_map(Plateau * game){
-    int i ;
-    initialise_joueur(&game->joueur);
-    printf(" x = %.0f \n",game->joueur.pos.x);
+static void init_objects_in_map(Plateau *game){
+    int i;
+
+    assert(NULL != game);
+
+    initialise_joueur(&(game->joueur));
+    printf(" x = %.0f \n", game->joueur.pos.x);
     init_Gardien(game);
     init_Relique(game);
     init_tuile(game);
-    game->plateau[(int)game->joueur.pos.x][(int)game->joueur.pos.y] = 4;
-    for(i = 0;i<NB_GARDIEN;i++){
-        game->plateau[(int)game->gardien[i].pos.x][(int)game->gardien[i].pos.y] =2;
-        printf("poser gardien %.0f %.0f \n",game->gardien[i].pos.x,game->gardien[i].pos.y);
-
-
+    game->plateau[(int)game->joueur.pos.x][(int)game->joueur.pos.y] = JOUEUR;
+    for(i = 0; i < NB_GARDIEN; i++){
+        game->plateau[(int)(game->gardien[i].pos.x)][(int)(game->gardien[i].pos.y)] = GARDIEN;
+        printf("poser gardien %.0f %.0f \n",game->gardien[i].pos.x, game->gardien[i].pos.y);
     }
-    for(i = 0;i<NB_RELIQUE;i++){
-        game->plateau[game->relique[i].pos.x][game->relique[i].pos.y]=3;
+    for(i = 0; i < NB_RELIQUE; i++){
+        game->plateau[game->relique[i].pos.x][game->relique[i].pos.y] = RELIQUE;
         printf("poser relique\n");
-
     }
-    for(i = 0;i<NB_TUILE;i++){
-        game->plateau[game->tuile[i].pos.x][game->tuile[i].pos.y]=5;
+    for(i = 0; i < NB_TUILE; i++){
+        game->plateau[game->tuile[i].pos.x][game->tuile[i].pos.y] = TUILE;
         printf("poser tuile\n");
     }
-
 }
-static void generation_wall_ext_print(Plateau game){
-    int i,j;
-    for (i= 0; i < LARGEUR_PLATEAU; i++)
-    {
-        for(j =0;j<LONGEUR_PLATEAU;j++){
-            printf("%d ",game.plateau[i][j]);
+
+
+static void generation_wall_ext_print(Plateau const *game){
+    int i, j;
+    for(i = 0; i < LARGEUR_PLATEAU; i++){
+        for(j = 0; j < LONGEUR_PLATEAU; j++){
+            if(game->plateau[i][j] == 0){
+                printf("  ");
+            }
+            else{
+                printf("%d ", game->plateau[i][j]);
+            }
         }
         printf("\n");
     }
-
-
 }
 
+
 void create_map(Plateau *game){
+    assert(NULL != game);
+
     init_plateau(game);
     generation_wall_ext(game);
-    generation_lenght_wall(58.0,43.0,1,game);
+    generation_lenght_wall(58.0, 43.0, 1, game);
     printf(" Le plateau de jeu apres : \n");
-    /*generation_wall_ext_print(*game);*/
+    generation_wall_ext_print(game);
     printf(" Le plateau de jeu apres  object : \n");
     init_objects_in_map(game);
-    /*generation_wall_ext_print(*game);*/
+    generation_wall_ext_print(game);
 }
 
 
diff --git a/src/Moteur_graphique.c b/src/Moteur_graphique.c
index 03a85dd..16553b0 100644
--- a/src/Moteur_graphique.c
+++ b/src/Moteur_graphique.c
@@ -128,7 +128,7 @@ void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur){
         }
     }
     dessine_gardien(p);
-    dessine_relique(p);
     dessine_tuile(p);
+    dessine_relique(p);
     MLV_actualise_window();
 }
diff --git a/src/main.c b/src/main.c
index 27b458a..4b5591f 100644
--- a/src/main.c
+++ b/src/main.c
@@ -59,11 +59,21 @@ int main(int argc, const char * const argv[]){
     MLV_Keyboard_button sym;
     MLV_Button_state state;
     MLV_Event event;
+    frametime = extratime = 0.0;
+    fin_de_partie = 1;
+    mod = MLV_KEYBOARD_KMOD_NONE;
+    sym = MLV_KEYBOARD_NONE;
+    state = MLV_RELEASED;
+    event = MLV_NONE;
 
-    /*srand(time(NULL));*/
+    srand(time(NULL));
     MLV_create_window("ko", "ka", LONGUEUR_FENETRE, LARGEUR_FENETRE);
     create_map(&plateau);
-    fin_de_partie = 1;
+    printf("%f - %f\n", plateau.gardien[0].pos.x, plateau.gardien[0].pos.y);
+    printf("%f - %f\n", plateau.gardien[1].pos.x, plateau.gardien[1].pos.y);
+    printf("%f - %f\n", plateau.gardien[2].pos.x, plateau.gardien[2].pos.y);
+    printf("%f - %f\n", plateau.gardien[3].pos.x, plateau.gardien[3].pos.y);
+    printf("%f - %f\n", plateau.gardien[4].pos.x, plateau.gardien[4].pos.y);
     /*aff_plat(&plateau);*/
 
     clock_gettime(CLOCK_REALTIME, &start);
@@ -123,6 +133,7 @@ int main(int argc, const char * const argv[]){
         else{
             plateau.joueur.vitesse = 0;
         }
+        /*
         switch(plateau.joueur.direction){
             case HAUT :printf("H : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
             case BAS :printf("B : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
@@ -130,6 +141,7 @@ int main(int argc, const char * const argv[]){
             case GAUCHE:printf("G : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
             default :break;
         }
+        */
 
         printf("vitesse:%f \n", plateau.joueur.vitesse);
         if(event == MLV_KEY){
@@ -159,7 +171,9 @@ int main(int argc, const char * const argv[]){
         frametime = new_time.tv_sec - end_time.tv_sec;
         frametime += (new_time.tv_sec - end_time.tv_sec) / 1.0E9;
         extratime = (1.0 / 60) - frametime;
+        /*
         printf("(1.0/60.0) = %f\nextratime : %f\nframetime : %f\n",(1.0 / 60.0), extratime, frametime);
+        */
 
         if(extratime > 0){
             MLV_wait_milliseconds((int)(extratime * 1000));

commit e9a4c52adc9e351f25b92dfe2a8ce8880267bb74
Author: Massiouane Maibeche <massiouane.maibeche@etud-upem.fr>
Date:   Thu Jan 5 14:49:54 2023 +0100

    ajoute d'evenement + fin de partie

diff --git a/bin/exe b/bin/exe
index cffb8dd..c15c8cc 100755
Binary files a/bin/exe and b/bin/exe differ
diff --git a/include/Collision.h b/include/Collision.h
index 1b545bf..e16dd24 100644
--- a/include/Collision.h
+++ b/include/Collision.h
@@ -1,6 +1,7 @@
 #ifndef __COLLISION__
 #define __COLLISION__
 
+#define MARGE_DISTANCE 0.25
 #include "Moteur_de_jeu.h"
 
 
@@ -11,15 +12,12 @@ int est_dans_relique(Joueur const *j, Relique const *r);
 int est_dans_tuile(Joueur const *j, Tuile const *t);
 
 
-/*A CHANGER LIRE SECTION 5 DU SUJET */
-int est_dans_mur(Position const *pos, Plateau const *plateau);
-
 int gardien_detecte_joueur(Gardien *g);
 
 /*Fonction qui calcule et renvoie la distance entre l'agent (Joueur/Gardien)
 et le prochain mur par rapport aux coord actuelles*/
 int distance_vers_mur(Plateau const *plateau, Position const *pos, Direction const *dir);
 
-int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const *dir, float *vitesse);
+int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const *dir,double/* float*/ *vitesse);
 
 #endif
diff --git a/include/Deplacement.h b/include/Deplacement.h
index 44c1e44..ddcb86e 100644
--- a/include/Deplacement.h
+++ b/include/Deplacement.h
@@ -21,7 +21,7 @@ typedef struct position_obj{
 }Position_obj;
 
 typedef struct position{
-    float x, y; /*position 2D*/
+    /*float*/double x, y; /*position 2D*/
 }Position;
 
 void change_direction(Position *p, Direction direction);
diff --git a/include/Joueur.h b/include/Joueur.h
index ffa3c50..d642f00 100644
--- a/include/Joueur.h
+++ b/include/Joueur.h
@@ -22,13 +22,13 @@ typedef struct joueur{
     int mana; /*temporaire pour la quantité de mana*/
     Direction direction;
     Mode_joueur mode;
-    float vitesse;
+    /*float*/double vitesse;
     Position pos;
 }Joueur;
 
 
-void init_vitesse_joueur(float *vitesse);
-void augmente_vitesse_joueur(Mode_joueur *mode, float *vitesse);
+void init_vitesse_joueur(/*float*/double *vitesse);
+void augmente_vitesse_joueur(Mode_joueur *mode, /*float*/double *vitesse);
 void config_joueur_mode_normal(Joueur *j);
 void initialise_joueur(Joueur *j);
 
diff --git a/include/Moteur_de_jeu.h b/include/Moteur_de_jeu.h
index 29ca700..11a9d4e 100644
--- a/include/Moteur_de_jeu.h
+++ b/include/Moteur_de_jeu.h
@@ -30,5 +30,6 @@ typedef struct {
 
 
 void create_map(Plateau *game);
+void change_etat_obj(Etat_objet *o);
 
 #endif
diff --git a/include/Moteur_graphique.h b/include/Moteur_graphique.h
index 1d1c085..8196672 100644
--- a/include/Moteur_graphique.h
+++ b/include/Moteur_graphique.h
@@ -2,7 +2,7 @@
 #define __MOTEUR_GRAPHIQUE__
 
 #include "Gestion_terrain.h"
-#define TAILLE_CASE 10
+#define TAILLE_CASE 15
 #define LONGUEUR_FENETRE (LONGEUR_PLATEAU * TAILLE_CASE)
 #define LARGEUR_FENETRE (LARGEUR_PLATEAU * TAILLE_CASE)
 
diff --git a/obj/Collision.o b/obj/Collision.o
index bb0cb04..8ce31e0 100644
Binary files a/obj/Collision.o and b/obj/Collision.o differ
diff --git a/obj/Deplacement.o b/obj/Deplacement.o
index c0351c5..a69d4dd 100644
Binary files a/obj/Deplacement.o and b/obj/Deplacement.o differ
diff --git a/obj/Gardien.o b/obj/Gardien.o
index 68edb95..c3378fc 100644
Binary files a/obj/Gardien.o and b/obj/Gardien.o differ
diff --git a/obj/Gestion_terrain.o b/obj/Gestion_terrain.o
index f9cb383..a5b4263 100644
Binary files a/obj/Gestion_terrain.o and b/obj/Gestion_terrain.o differ
diff --git a/obj/Joueur.o b/obj/Joueur.o
index 6aedb14..0a5d60f 100644
Binary files a/obj/Joueur.o and b/obj/Joueur.o differ
diff --git a/obj/Moteur_de_jeu.o b/obj/Moteur_de_jeu.o
index 04bec7f..bef860c 100644
Binary files a/obj/Moteur_de_jeu.o and b/obj/Moteur_de_jeu.o differ
diff --git a/obj/Moteur_graphique.o b/obj/Moteur_graphique.o
index d14a02b..4cd2f3e 100644
Binary files a/obj/Moteur_graphique.o and b/obj/Moteur_graphique.o differ
diff --git a/obj/main.o b/obj/main.o
index 0844853..c09c8ae 100644
Binary files a/obj/main.o and b/obj/main.o differ
diff --git a/src/Collision.c b/src/Collision.c
index 0ce6964..8ea7384 100644
--- a/src/Collision.c
+++ b/src/Collision.c
@@ -23,21 +23,16 @@ pour voir ce qu'il va y trouver*/
 
 
 
-int est_dans_relique(Joueur const *j, Relique const *r){
-    /*TO DO*/
-    return 0;
+/*Renvoie 1 si coord j est ds relique et 0 sinon*/
+int est_dans_relique(Joueur const *joueur, Relique const *relique){
+    return ((int)(joueur->pos.x) == relique->pos.x && (int)(joueur->pos.y) == relique->pos.y) ? 1 : 0;
 }
 
-
-int est_dans_tuile(Joueur const *j, Tuile const *t){
-    return 0;
+/*Renvoie 1 si coord j est ds relique et 0 sinon*/
+int est_dans_tuile(Joueur const *joueur, Tuile const *tuile){
+    return ((int)(joueur->pos.x) == tuile->pos.x && (int)(joueur->pos.y) == tuile->pos.y) ? 1 : 0;
 }
 
-/*peut être mettre en palce un enum ou des defines pour les 1 mur / 2 relique etc...*/
-/*Prend les coord d'un gardien ou d'un joueur*/
-int est_dans_mur(Position const *pos, Plateau const *P){
-    return 0;
-}
 
 
 int gardien_detecte_joueur(Gardien *g){
@@ -86,27 +81,137 @@ int distance_vers_mur(Plateau const *plateau, Position const *pos, Direction con
     return cpt;
 }
 
+/*Si collision à gauche ou en haut (=selon dir_tmp) la vitesse est coupé, sinon aucune action*/
+static void collision_coin_haut_gauche(Plateau const *plateau, Position *pos, double/*float*/ *vitesse, Direction *dir_tmp){
+    int distance_du_mur;
+    distance_du_mur = distance_vers_mur(plateau, pos, dir_tmp);
+    /*A CHANGER >>*/
+    if(distance_du_mur > 1){return ;}
+    switch(*dir_tmp){
+        case GAUCHE: if(pos->x < (int)(pos->x) + 0.5){
+                        if((int)(pos->y) + (*vitesse) > (int)(pos->y) + 1 - sqrt((1.0/4 - (pos->x - (int)(pos->x)) * (pos->x - (int)(pos->x))))){
+                            *vitesse = 0.0;
+                        }
+                     }
+                     break;
+        case HAUT: if(pos->y < (int)(pos->y) + 0.5){
+                     if((int)(pos->x) + (*vitesse) > (int)(pos->x) + 1 - sqrt((1.0/4 - (pos->y - (int)(pos->y)) * (pos->y - (int)(pos->y))))){
+                         *vitesse = 0.0;
+                     }
+                  }
+                  break;
+        default : break;
+    }
+}
+
+/*Si collision à droite ou en haut (=selon dir_tmp) la vitesse est coupé, sinon aucune action*/
+static void collision_coin_haut_droite(Plateau const *plateau, Position *pos, double/*float*/ *vitesse, Direction *dir_tmp){
+    int distance_du_mur;
+    distance_du_mur = distance_vers_mur(plateau, pos, dir_tmp);
+    /*A CHANGER >>*/
+    if(distance_du_mur > 1){return ;}
+    switch(*dir_tmp){
+        case DROITE: if(pos->x >= (int)(pos->x) + 0.5){
+                        if((int)(pos->y) + (*vitesse) > (int)(pos->y) + 1 - sqrt((1.0/4 - (pos->x - (int)(pos->x)) * (pos->x - (int)(pos->x))))){
+                            *vitesse = 0.0;
+                        }
+                     }
+                     break;
+        case HAUT: if(pos->y >= (int)(pos->y) + 0.5){
+                     if((int)(pos->x) + (*vitesse) > (int)(pos->x) + 1 - sqrt((1.0/4 - (pos->y - (int)(pos->y)) * (pos->y - (int)(pos->y))))){
+                         *vitesse = 0.0;
+                     }
+                  }
+                  break;
+        default : break;
+    }
+}
+
+/*Si collision à gauche ou en bas (=selon dir_tmp) la vitesse est coupé, sinon aucune action*/
+static void collision_coin_bas_gauche(Plateau const *plateau, Position *pos, double/*float*/ *vitesse, Direction *dir_tmp){
+    int distance_du_mur;
+    distance_du_mur = distance_vers_mur(plateau, pos, dir_tmp);
+
+    if(distance_du_mur > 1){return ;}
+    switch(*dir_tmp){
+        case GAUCHE: if(pos->x < (int)(pos->x) + 0.5){
+                        if((int)(pos->y) + (*vitesse) > (int)(pos->y) + 1 - sqrt((1.0/4 - (pos->x - (int)(pos->x)) * (pos->x - (int)(pos->x))))){
+                            *vitesse = 0.0;
+                        }
+                     }
+                     break;
+        case BAS: if(pos->y < (int)(pos->y) + 0.5){
+                     if((int)(pos->x) + (*vitesse) > (int)(pos->x) + 1 - sqrt((1.0/4 - (pos->y - (int)(pos->y)) * (pos->y - (int)(pos->y))))){
+                         *vitesse = 0.0;
+                     }
+                  }
+                  break;
+        default : break;
+    }
+}
+
+/*Si collision à droite ou en bas (=selon dir_tmp) la vitesse est coupé, sinon aucune action*/
+static void collision_coin_bas_droite(Plateau const *plateau, Position *pos, double/*float*/ *vitesse, Direction *dir_tmp){
+    int distance_du_mur;
+    distance_du_mur = distance_vers_mur(plateau, pos, dir_tmp);
+    if(distance_du_mur > 1){return ;}
+
+    switch(*dir_tmp){
+        case DROITE: if(pos->x >= (int)(pos->x) + 0.5){
+                        if((int)(pos->y) + (*vitesse) > (int)(pos->y) + 1 - sqrt((1.0/4 - ((int)(pos->x) + 1 - pos->x) * ((int)(pos->x) + 1 - pos->x)))){
+                            *vitesse = 0.0;
+                        }
+                    }
+                    break;
+        case BAS: if(pos->y >= (int)(pos->y) + 0.5){
+                     if((int)(pos->x) + (*vitesse) > (int)(pos->x) + 1 - sqrt((1.0/4 - ((int)(pos->y) + 1 - pos->y) * ((int)(pos->y) + 1 - pos->y)))){
+                        *vitesse = 0.0;
+                     }
+                  }
+                  break;
+        default : break;
+    }
+
+}
+
 /*Retourne 0 si il n'y a aucune collision avec un mur et 1 sinon*/
-int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const *dir, float *vitesse){
+int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const *dir,double/* float*/ *vitesse){
     int distance_du_mur;
+    Direction tmp_dir;
     distance_du_mur = distance_vers_mur(plateau, pos, dir);
     if(distance_du_mur > 1) return 0;
     switch(*dir){
-        case HAUT : if((int)(pos->y) - (*vitesse + INCREMENTE_VITESSE_JOUEUR) > (int)(pos->y) - 0.5){
+        case HAUT : if((int)(pos->y) - (*vitesse) > (int)(pos->y) + 0.5){
                         *vitesse = 0.0;
                     }
+                    tmp_dir = DROITE;
+                    collision_coin_haut_droite(plateau, pos, vitesse, &tmp_dir);
+                    tmp_dir = GAUCHE;
+                    collision_coin_haut_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case BAS : if((int)(pos->y) + (*vitesse + INCREMENTE_VITESSE_JOUEUR) > (int)(pos->y) + 0.5){
+        case BAS :  if((int)(pos->y) + (*vitesse ) > (int)(pos->y) + 0.5){
                         *vitesse = 0.0;
                     }
+                    tmp_dir = DROITE;
+                    collision_coin_bas_droite(plateau, pos, vitesse, &tmp_dir);
+                    tmp_dir = GAUCHE;
+                    collision_coin_bas_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case GAUCHE : if((int)(pos->x) - (*vitesse + INCREMENTE_VITESSE_JOUEUR) > (int)(pos->x) - 0.5){
+        case GAUCHE : if((int)(pos->x) - (*vitesse ) > (int)(pos->x) + 0.5){
                         *vitesse = 0.0;
                     }
+                    tmp_dir = BAS;
+                    collision_coin_bas_gauche(plateau, pos, vitesse, &tmp_dir);
+                    tmp_dir = HAUT;
+                    collision_coin_haut_gauche(plateau, pos, vitesse, &tmp_dir);
                     break;
-        case DROITE : if((int)(pos->x) + (*vitesse + INCREMENTE_VITESSE_JOUEUR) > (int)(pos->x) + 0.5){
+        case DROITE : if((int)(pos->x) + (*vitesse ) > (int)(pos->x) + 0.5){
                         *vitesse = 0.0;
                     }
+                    tmp_dir = BAS;
+                    collision_coin_bas_droite(plateau, pos, vitesse, &tmp_dir);
+                    tmp_dir = HAUT;
+                    collision_coin_haut_droite(plateau, pos, vitesse, &tmp_dir);
                     break;
         default : break;
     }
diff --git a/src/Gestion_terrain.c b/src/Gestion_terrain.c
index 2852c94..1caccd0 100644
--- a/src/Gestion_terrain.c
+++ b/src/Gestion_terrain.c
@@ -48,6 +48,7 @@ int interaction_joueur_tuile(Plateau *p){
 
 
 void interaction_gardien_gardien(){
+
     return ;
 }
 
@@ -58,8 +59,8 @@ void deplacement_joueur(Plateau *p){
 }
 
 int fin_de_jeu(Joueur const *j){
-    if(j->pos.x == COORD_FIN_DE_JEU_X &&
-        j->pos.y == COORD_FIN_DE_JEU_Y &&
+    if((int)j->pos.x == COORD_FIN_DE_JEU_X &&
+        (int)j->pos.y == COORD_FIN_DE_JEU_Y &&
         j->nb_relique == NB_RELIQUE){
             return 1;
         }
diff --git a/src/Joueur.c b/src/Joueur.c
index 33c2a9e..93bcdf4 100644
--- a/src/Joueur.c
+++ b/src/Joueur.c
@@ -1,7 +1,7 @@
 #include "../include/Joueur.h"
 
 /*s'occupe de changer la vitesse selon le mode*/
-static void change_vitesse_joueur(Mode_joueur *mode, float *vitesse){
+static void change_vitesse_joueur(Mode_joueur *mode, double/*float */*vitesse){
     if(*mode == MODE_ACCELERE && *vitesse < 1.2){
         *vitesse += INCREMENTE_VITESSE_JOUEUR;
         if(*vitesse > 1.2){
@@ -17,7 +17,7 @@ static void change_vitesse_joueur(Mode_joueur *mode, float *vitesse){
 }
 
 /*augmente la vitesse d'un joueur */
-void augmente_vitesse_joueur(Mode_joueur *mode, float *vitesse){
+void augmente_vitesse_joueur(Mode_joueur *mode, /**float*/double *vitesse){
     switch(*mode){
         case AUCUN_MODE :  change_vitesse_joueur(mode, vitesse);
                             break;
diff --git a/src/Moteur_de_jeu.c b/src/Moteur_de_jeu.c
index ee28eea..da39e21 100644
--- a/src/Moteur_de_jeu.c
+++ b/src/Moteur_de_jeu.c
@@ -195,7 +195,7 @@ static void generation_wall_on_game_by_line(double line,int direction,int nb,Pla
 
 }
 
-static void generation_lenght_wall(double height,double lenght,int nb ,Plateau *game){
+static void generation_lenght_wall(double height, double lenght, int nb, Plateau *game){
     double x, y, line;
     int mur;
     x = height < lenght ? lenght : height;
@@ -310,9 +310,9 @@ static void init_tuile(Plateau * game){
         game->tuile[i].mana = 60;
         game->tuile[i].etat = NON_RECUPERER;
         while(1){
-            x = rand()%57+1;
-            y=rand()%42+1;
-            if(position_verification(x,y,*game)==1){
+            x = 1 + rand() % 57;
+            y = 1 + rand() % 42;
+            if(position_verification(x, y, *game) == 1){
                 game->tuile[i].pos.x = x;
                 game->tuile[i].pos.y = y;
                 break;
diff --git a/src/Moteur_graphique.c b/src/Moteur_graphique.c
index a0cc693..03a85dd 100644
--- a/src/Moteur_graphique.c
+++ b/src/Moteur_graphique.c
@@ -17,7 +17,7 @@ static void dessine_quadrillage(int longueur, int largeur){
     for(i = 0; i <= longueur; i += TAILLE_CASE){
         MLV_draw_filled_rectangle(i, 0, 0, largeur, MLV_COLOR_BLACK);
     }
-    printf("q-OK\n");
+    /*printf("q-OK\n");*/
 }
 
 static void dessine_mur(int *x, int *y, int taille_mur){
diff --git a/src/main.c b/src/main.c
index 3c121d5..27b458a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -5,6 +5,7 @@
 #include "../include/Gestion_terrain.h"
 #include "../include/Moteur_graphique.h"
 #include "MLV/MLV_all.h"
+#include <time.h>
 
 static void aff_plat(Plateau *plat){
     int i, j;
@@ -49,6 +50,7 @@ else{
 
 
 int main(int argc, const char * const argv[]){
+    int fin_de_partie;
     Plateau plateau;
     struct timespec new_time, end_time;
     double frametime, extratime;
@@ -58,11 +60,12 @@ int main(int argc, const char * const argv[]){
     MLV_Button_state state;
     MLV_Event event;
 
+    /*srand(time(NULL));*/
     MLV_create_window("ko", "ka", LONGUEUR_FENETRE, LARGEUR_FENETRE);
     create_map(&plateau);
-    /*aff_plat(&plateau);
-    */
-    srand(time(NULL));
+    fin_de_partie = 1;
+    /*aff_plat(&plateau);*/
+
     clock_gettime(CLOCK_REALTIME, &start);
     plateau.joueur.direction = HAUT;
     printf("H->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
@@ -72,7 +75,7 @@ int main(int argc, const char * const argv[]){
     printf("G->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
     plateau.joueur.direction = DROITE;
     printf("D->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
-    while(1){
+    while(fin_de_partie){
         /*CALCUL_DE_TEMPS*/
         clock_gettime(CLOCK_REALTIME, &end_time);
         dessine_plateau_graphique(&plateau, LONGEUR_PLATEAU, LARGEUR_PLATEAU);
@@ -144,12 +147,13 @@ int main(int argc, const char * const argv[]){
             }*/
             if(sym == MLV_KEYBOARD_t){
                 aff_plat(&plateau);
-                sleep(2);
                 break;
             }
         }
 
         /*Mecanisme de jeu et tt*/
+        interaction_joueur_relique(&plateau);
+        interaction_joueur_tuile(&plateau);
         /* ... */
         clock_gettime(CLOCK_REALTIME, &new_time);
         frametime = new_time.tv_sec - end_time.tv_sec;
@@ -160,6 +164,9 @@ int main(int argc, const char * const argv[]){
         if(extratime > 0){
             MLV_wait_milliseconds((int)(extratime * 1000));
         }
+        if(fin_de_jeu(&(plateau.joueur))){
+            fin_de_partie = 0;
+        }
     }
     clock_gettime(CLOCK_REALTIME, &end);
     /*Chrono rapide du joueur - a ameliorer eventuellement ==> */

commit 52dc2ac8c457564fa5c2524a6105d615b4170926
Author: Massiouane Maibeche <massiouane.maibeche@etud-upem.fr>
Date:   Wed Jan 4 11:07:21 2023 +0100

    ajout de ce qu'on à fait depuis le debut

diff --git a/bin/exe b/bin/exe
new file mode 100755
index 0000000..cffb8dd
Binary files /dev/null and b/bin/exe differ
diff --git a/include/Collision.h b/include/Collision.h
new file mode 100644
index 0000000..1b545bf
--- /dev/null
+++ b/include/Collision.h
@@ -0,0 +1,25 @@
+#ifndef __COLLISION__
+#define __COLLISION__
+
+#include "Moteur_de_jeu.h"
+
+
+/*renvoie 1 si le joueur est sur un relique ou 0 sinon*/
+int est_dans_relique(Joueur const *j, Relique const *r);
+
+/*renvoie 1 si la pos du joueur est sur la meme pos que la tuile ou 0 sinon.*/
+int est_dans_tuile(Joueur const *j, Tuile const *t);
+
+
+/*A CHANGER LIRE SECTION 5 DU SUJET */
+int est_dans_mur(Position const *pos, Plateau const *plateau);
+
+int gardien_detecte_joueur(Gardien *g);
+
+/*Fonction qui calcule et renvoie la distance entre l'agent (Joueur/Gardien)
+et le prochain mur par rapport aux coord actuelles*/
+int distance_vers_mur(Plateau const *plateau, Position const *pos, Direction const *dir);
+
+int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const *dir, float *vitesse);
+
+#endif
diff --git a/include/Deplacement.h b/include/Deplacement.h
new file mode 100644
index 0000000..44c1e44
--- /dev/null
+++ b/include/Deplacement.h
@@ -0,0 +1,28 @@
+#ifndef __DEPLACEMENT__
+#define __DEPLACEMENT__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <string.h>
+#include <assert.h>
+#include <unistd.h>
+#include <math.h>
+
+typedef enum{
+    HAUT,
+    BAS,
+    GAUCHE,
+    DROITE
+}Direction;
+
+typedef struct position_obj{
+    int x, y; /*position 2D*/
+}Position_obj;
+
+typedef struct position{
+    float x, y; /*position 2D*/
+}Position;
+
+void change_direction(Position *p, Direction direction);
+#endif
diff --git a/include/Gardien.h b/include/Gardien.h
new file mode 100644
index 0000000..cf21739
--- /dev/null
+++ b/include/Gardien.h
@@ -0,0 +1,40 @@
+#ifndef __GARDIEN__
+#define __GARDIEN__
+
+#define NORMAL 4
+#define PANIQUE 6
+
+#include "Deplacement.h"
+
+
+typedef enum{
+    MODE_NORMAL,
+    MODE_PANIQUE
+}Etat_gardien;
+
+typedef enum{
+    JOUEUR_NON_DETECTE,
+    JOUEUR_DETECTE
+}Etat_detecte;
+
+typedef struct gardien {
+    int cpt_panique;
+    Etat_gardien alerte; /*type d'alerte du gardien*/
+    Etat_detecte detecte; /*detection d'un joueur*/
+    int distance_detection;
+    Direction direction;
+    Position pos;
+    float vitesse;
+}Gardien;
+
+
+void change_vitesse_gardien(Etat_gardien *etat, float *vitesse);
+void change_direction_(Direction *d);
+void config_gardien_mode_normal(Gardien *g);
+void config_gardien_mode_panique(Gardien *g);
+void initalise_gardien(Gardien *g);
+
+
+void affiche_info_gardien(Gardien *g);
+
+#endif
diff --git a/include/Gestion_terrain.h b/include/Gestion_terrain.h
new file mode 100644
index 0000000..45cc6f7
--- /dev/null
+++ b/include/Gestion_terrain.h
@@ -0,0 +1,17 @@
+#ifndef __GESTION_TERRAIN__
+#define __GESTION_TERRAIN__
+
+#include "Collision.h"
+
+int interaction_joueur_relique(Plateau *p);
+int interaction_joueur_tuile(Plateau *p);
+void deplacement_joueur(Plateau *p);
+
+/*faire en sorte de recevoir les 2 gardiens qui veulent se rentrer dedans et les renvoyant dans des direction differente*/
+void interaction_gardien_gardien();
+
+/*retourne 1 si le joueur possede les 3 reliques et qu'il se trouve dans ses coord initiale, ou 0 sinon.*/
+int fin_de_jeu(Joueur const *j);
+
+
+#endif
diff --git a/include/Joueur.h b/include/Joueur.h
new file mode 100644
index 0000000..ffa3c50
--- /dev/null
+++ b/include/Joueur.h
@@ -0,0 +1,38 @@
+#ifndef __JOUEUR__
+#define __JOUEUR__
+
+#define LONGUEUR 60
+#define LARGEUR 45
+#define VITESSE_JOUEUR_BASE 0.1
+#define COORD_FIN_DE_JEU_X 2
+#define COORD_FIN_DE_JEU_Y 2
+#define INCREMENTE_VITESSE_JOUEUR 0.03
+
+#include "Deplacement.h"
+
+
+typedef enum{
+    AUCUN_MODE,
+    MODE_INVISIBLE,
+    MODE_ACCELERE
+}Mode_joueur;
+
+typedef struct joueur{
+    int nb_relique; /*temporaire pour le nombre de relique*/
+    int mana; /*temporaire pour la quantité de mana*/
+    Direction direction;
+    Mode_joueur mode;
+    float vitesse;
+    Position pos;
+}Joueur;
+
+
+void init_vitesse_joueur(float *vitesse);
+void augmente_vitesse_joueur(Mode_joueur *mode, float *vitesse);
+void config_joueur_mode_normal(Joueur *j);
+void initialise_joueur(Joueur *j);
+
+
+void affiche_info_joueur(Joueur const *j);
+
+#endif
diff --git a/include/Moteur_de_jeu.h b/include/Moteur_de_jeu.h
new file mode 100644
index 0000000..29ca700
--- /dev/null
+++ b/include/Moteur_de_jeu.h
@@ -0,0 +1,34 @@
+#ifndef __MOTEUR_DE_JEU__
+#define __MOTEUR_DE_JEU__
+
+#include "Relique.h"
+#include "Gardien.h"
+#include "Joueur.h"
+#include <math.h>
+
+#define LARGEUR_PLATEAU 45
+#define LONGEUR_PLATEAU 60
+#define NB_RELIQUE 3
+#define NB_GARDIEN 5
+#define NB_TUILE 20
+#define minside 9
+
+
+typedef struct {
+    Etat_objet etat;
+    Position_obj pos;
+    int mana;/*60*/
+}Tuile;
+
+typedef struct {
+    int plateau [LARGEUR_PLATEAU][LONGEUR_PLATEAU];
+    Joueur joueur;
+    Gardien gardien[NB_GARDIEN];
+    Relique relique[NB_RELIQUE];
+    Tuile tuile[NB_TUILE];
+} Plateau;
+
+
+void create_map(Plateau *game);
+
+#endif
diff --git a/include/Moteur_graphique.h b/include/Moteur_graphique.h
new file mode 100644
index 0000000..1d1c085
--- /dev/null
+++ b/include/Moteur_graphique.h
@@ -0,0 +1,19 @@
+#ifndef __MOTEUR_GRAPHIQUE__
+#define __MOTEUR_GRAPHIQUE__
+
+#include "Gestion_terrain.h"
+#define TAILLE_CASE 10
+#define LONGUEUR_FENETRE (LONGEUR_PLATEAU * TAILLE_CASE)
+#define LARGEUR_FENETRE (LARGEUR_PLATEAU * TAILLE_CASE)
+
+/*
+0 : case vide
+1 : mur
+2 : gardien
+3 : relique
+4 : joueur
+*/
+
+void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur);
+
+#endif
diff --git a/include/Relique.h b/include/Relique.h
new file mode 100644
index 0000000..01cd3d1
--- /dev/null
+++ b/include/Relique.h
@@ -0,0 +1,23 @@
+#ifndef __RELIQUE__
+#define __RELIQUE__
+
+
+#include "Deplacement.h"
+
+
+typedef enum{
+    NON_RECUPERER,
+    RECUPERER
+}Etat_objet;
+
+typedef struct relique{
+    Etat_objet etat;
+    Position_obj pos;
+}Relique;
+
+
+void initialise_relique(Relique *r);
+
+void affiche_info_relique(Relique const *r);
+
+#endif
diff --git a/makefile b/makefile
new file mode 100644
index 0000000..9ce3380
--- /dev/null
+++ b/makefile
@@ -0,0 +1,49 @@
+CC = gcc
+CFLAGS = -ansi -Wall -pedantic
+LDFLAGS =-lm -lrt
+MLV= -lMLV
+OBJ = obj/main.o obj/Collision.o obj/Gardien.o obj/Gestion_terrain.o obj/Joueur.o obj/Moteur_de_jeu.o obj/Moteur_graphique.o obj/Relique.o obj/Deplacement.o
+DIR_SRC = src
+DIR_OBJ = obj
+DIR_HEADER = include
+DIR_BIN = bin
+TARGET = exe
+
+all: $(DIR_BIN)/$(TARGET)
+
+$(DIR_BIN)/$(TARGET): $(OBJ)
+	$(CC) $(CFLAGS) -o $@  $^ $(LDFLAGS) $(MLV)
+
+$(DIR_OBJ)/main.o: $(DIR_SRC)/main.c $(DIR_HEADER)/Gestion_terrain.h $(DIR_HEADER)/Moteur_graphique.h
+	$(CC) -c $< -o $(DIR_OBJ)/main.o $(CFLAGS)
+
+$(DIR_OBJ)/Deplacement.o: $(DIR_SRC)/Deplacement.c $(DIR_HEADER)/Deplacement.h
+	$(CC) -c $< -o $(DIR_OBJ)/Deplacement.o $(CFLAGS)
+
+$(DIR_OBJ)/Relique.o: $(DIR_SRC)/Relique.c $(DIR_HEADER)/Relique.h
+	$(CC) -c $< -o $(DIR_OBJ)/Relique.o $(CFLAGS)
+
+$(DIR_OBJ)/Gardien.o: $(DIR_SRC)/Gardien.c $(DIR_HEADER)/Gardien.h $(DIR_HEADER)/Deplacement.h
+	$(CC) -c $< -o $(DIR_OBJ)/Gardien.o $(CFLAGS)
+
+$(DIR_OBJ)/Joueur.o: $(DIR_SRC)/Joueur.c $(DIR_HEADER)/Joueur.h $(DIR_HEADER)/Deplacement.h
+	$(CC) -c $< -o $(DIR_OBJ)/Joueur.o $(CFLAGS)
+
+$(DIR_OBJ)/Moteur_graphique.o: $(DIR_SRC)/Moteur_graphique.c $(DIR_HEADER)/Moteur_graphique.h $(DIR_HEADER)/Gestion_terrain.h
+	$(CC) -c $< -o $(DIR_OBJ)/Moteur_graphique.o $(CFLAGS) $(MLV)
+
+$(DIR_OBJ)/Moteur_de_jeu.o: $(DIR_SRC)/Moteur_de_jeu.c $(DIR_HEADER)/Moteur_de_jeu.h $(DIR_HEADER)/Relique.h $(DIR_HEADER)/Gardien.h $(DIR_HEADER)/Joueur.h
+	$(CC) -c $< -o $(DIR_OBJ)/Moteur_de_jeu.o $(CFLAGS)
+
+$(DIR_OBJ)/Collision.o: $(DIR_SRC)/Collision.c $(DIR_HEADER)/Collision.h $(DIR_HEADER)/Moteur_de_jeu.h
+	$(CC) -c $< -o $(DIR_OBJ)/Collision.o $(CFLAGS)
+
+$(DIR_OBJ)/Gestion_terrain.o: $(DIR_SRC)/Gestion_terrain.c $(DIR_HEADER)/Gestion_terrain.h $(DIR_HEADER)/Collision.h
+	$(CC) -c $< -o $(DIR_OBJ)/Gestion_terrain.o $(CFLAGS)
+
+#Au cas ou on ajouterrai d'autre module
+#$(DIR_OBJ)/arboresence.o: $(DIR_SRC)/.c $(DIR_HEADER)/.h
+#	$(CC) -c $< -o $(DIR_OBJ)/.o $(CFLAGS)
+
+clean:
+	rm -f $(OBJ) $(TARGET)
diff --git a/obj/Collision.o b/obj/Collision.o
new file mode 100644
index 0000000..bb0cb04
Binary files /dev/null and b/obj/Collision.o differ
diff --git a/obj/Deplacement.o b/obj/Deplacement.o
new file mode 100644
index 0000000..c0351c5
Binary files /dev/null and b/obj/Deplacement.o differ
diff --git a/obj/Gardien.o b/obj/Gardien.o
new file mode 100644
index 0000000..68edb95
Binary files /dev/null and b/obj/Gardien.o differ
diff --git a/obj/Gestion_terrain.o b/obj/Gestion_terrain.o
new file mode 100644
index 0000000..f9cb383
Binary files /dev/null and b/obj/Gestion_terrain.o differ
diff --git a/obj/Joueur.o b/obj/Joueur.o
new file mode 100644
index 0000000..6aedb14
Binary files /dev/null and b/obj/Joueur.o differ
diff --git a/obj/Moteur_de_jeu.o b/obj/Moteur_de_jeu.o
new file mode 100644
index 0000000..04bec7f
Binary files /dev/null and b/obj/Moteur_de_jeu.o differ
diff --git a/obj/Moteur_graphique.o b/obj/Moteur_graphique.o
new file mode 100644
index 0000000..d14a02b
Binary files /dev/null and b/obj/Moteur_graphique.o differ
diff --git a/obj/Relique.o b/obj/Relique.o
new file mode 100644
index 0000000..4133ac9
Binary files /dev/null and b/obj/Relique.o differ
diff --git a/obj/main.o b/obj/main.o
new file mode 100644
index 0000000..0844853
Binary files /dev/null and b/obj/main.o differ
diff --git a/src/Collision.c b/src/Collision.c
new file mode 100644
index 0000000..0ce6964
--- /dev/null
+++ b/src/Collision.c
@@ -0,0 +1,114 @@
+#include "../include/Collision.h"
+
+
+/*Prashath*/
+/*
+colision vision gardien et colision physique du gardein
+colis tuile
+collis relique
+Collis joueur/gardien
+joeur/mur et gardien /mur
+joueur & relique
+detec limite de map joueur (ou golem)
+detection gardien alentoure
+que des fonction boolean de verification
+*/
+
+
+
+/*en fait avant de deplacer le personnage
+on renverra avec une fonction bis les coordonnées futur du Joueur
+pour voir ce qu'il va y trouver*/
+
+
+
+
+int est_dans_relique(Joueur const *j, Relique const *r){
+    /*TO DO*/
+    return 0;
+}
+
+
+int est_dans_tuile(Joueur const *j, Tuile const *t){
+    return 0;
+}
+
+/*peut être mettre en palce un enum ou des defines pour les 1 mur / 2 relique etc...*/
+/*Prend les coord d'un gardien ou d'un joueur*/
+int est_dans_mur(Position const *pos, Plateau const *P){
+    return 0;
+}
+
+
+int gardien_detecte_joueur(Gardien *g){
+    return 0;
+}
+
+/*testé et fonctionne
+(peut être initialiser le cpt à -1)*/
+int distance_vers_mur(Plateau const *plateau, Position const *pos, Direction const *dir){
+    int cpt, indice_x, indice_y;
+    assert(NULL != plateau);
+    assert(NULL != pos);
+    assert(NULL != dir);
+    cpt = 0;
+    switch(*dir){
+        case HAUT : indice_y = (int)pos->y;
+                    indice_x = (int)pos->x;
+                    while(plateau->plateau[indice_y][indice_x] != 1){
+                        --indice_y;
+                        ++cpt;
+                    }break;
+
+        case BAS : indice_y = (int)pos->y;
+                   indice_x = (int)pos->x;
+                   while(plateau->plateau[indice_y][indice_x] != 1){
+                       ++indice_y;
+                       ++cpt;
+                   }break;
+
+        case GAUCHE : indice_y = (int)pos->y;
+                      indice_x = (int)pos->x;
+                      while(plateau->plateau[indice_y][indice_x] != 1){
+                          --indice_x;
+                          ++cpt;
+                      }break;
+
+        case DROITE : indice_y = (int)pos->y;
+                      indice_x = (int)pos->x;
+                      while(plateau->plateau[indice_y][indice_x] != 1){
+                          ++indice_x;
+                          ++cpt;
+                      }break;
+
+        default : break;
+    }
+    return cpt;
+}
+
+/*Retourne 0 si il n'y a aucune collision avec un mur et 1 sinon*/
+int collision_contre_mur(Plateau const *plateau, Position *pos, Direction const *dir, float *vitesse){
+    int distance_du_mur;
+    distance_du_mur = distance_vers_mur(plateau, pos, dir);
+    if(distance_du_mur > 1) return 0;
+    switch(*dir){
+        case HAUT : if((int)(pos->y) - (*vitesse + INCREMENTE_VITESSE_JOUEUR) > (int)(pos->y) - 0.5){
+                        *vitesse = 0.0;
+                    }
+                    break;
+        case BAS : if((int)(pos->y) + (*vitesse + INCREMENTE_VITESSE_JOUEUR) > (int)(pos->y) + 0.5){
+                        *vitesse = 0.0;
+                    }
+                    break;
+        case GAUCHE : if((int)(pos->x) - (*vitesse + INCREMENTE_VITESSE_JOUEUR) > (int)(pos->x) - 0.5){
+                        *vitesse = 0.0;
+                    }
+                    break;
+        case DROITE : if((int)(pos->x) + (*vitesse + INCREMENTE_VITESSE_JOUEUR) > (int)(pos->x) + 0.5){
+                        *vitesse = 0.0;
+                    }
+                    break;
+        default : break;
+    }
+    return 1;
+}
diff --git a/src/Deplacement.c b/src/Deplacement.c
new file mode 100644
index 0000000..37a6d1e
--- /dev/null
+++ b/src/Deplacement.c
@@ -0,0 +1,12 @@
+#include "../include/Deplacement.h"
+
+void change_direction(Position *p, Direction direction){
+    assert(NULL != p);
+    switch(direction){
+        case HAUT : p->x -= 1; break;
+        case BAS : p->y -= 1; break;
+        case GAUCHE : p->x += 1; break;
+        case DROITE : p->y += 1; break;
+        default : break;
+    }
+}
diff --git a/src/Gardien.c b/src/Gardien.c
new file mode 100644
index 0000000..a1f8c62
--- /dev/null
+++ b/src/Gardien.c
@@ -0,0 +1,106 @@
+#include "../include/Gardien.h"
+
+/*massi*/
+/*
+leur vision (joueur et relique)
+-->mouvement et maniere de bouger
+
+mode panique si relique disparu
+30 sec renit quand detect gardient
+--> detec relique disparu .
+*/
+
+
+
+/*attribue une vitesse aleatoire*/
+void change_vitesse_gardien(Etat_gardien *etat, float *vitesse){
+    assert(NULL != vitesse);
+    assert(NULL != etat);
+    switch(*etat){
+        case MODE_NORMAL : *vitesse = (30.0 + rand() % (80 - 30)) / 100.0; break;
+        case MODE_PANIQUE : *vitesse = 1.0; break;
+        default : printf("mode non reconnu - vitesse nulle"); *vitesse = 0.0; break;
+    }
+}
+
+/*Change la direction d'un gardien
+tenir compte dans la fonction :
+                - des murs à proximité (si il est en face d'un mur qui retourne pas dedans quoi)
+*/
+void change_direction_(Direction *d){
+    int pos;
+    assert(NULL != d);
+    do{
+        pos = rand() % 4;
+    }while(pos == *d);
+    *d = pos;
+}
+
+/*configure le mode normal*/
+void config_gardien_mode_normal(Gardien *g){
+    assert(NULL != g);
+    g->alerte = MODE_NORMAL;
+    g->detecte = JOUEUR_NON_DETECTE;
+    g->distance_detection = NORMAL;
+    change_vitesse_gardien(&(g->alerte), &(g->vitesse));
+    change_direction_(&(g->direction));
+}
+/*configure le mode panique*/
+void config_gardien_mode_panique(Gardien *g){
+    assert(NULL != g);
+    g->alerte = MODE_PANIQUE;
+    g->detecte = JOUEUR_NON_DETECTE;
+    g->distance_detection = PANIQUE;
+    change_vitesse_gardien(&(g->alerte), &(g->vitesse));
+    change_direction_(&(g->direction));
+}
+
+/*Initialise les champs d'un gardien*/
+void initalise_gardien(Gardien *g){
+    assert(NULL != g);
+
+    if(NULL == g){
+        fprintf(stderr, "Gardien NULL");
+        return;
+    }
+    g->direction = -1;
+    g->cpt_panique = 0;
+    printf("(champs à ingnoré)-> direction initial = %d\n", g->direction);
+    /*init_coord_aleatoire(&(g->pos));*/
+    config_gardien_mode_normal(g);
+
+}
+
+
+/*A SUPP APRES - Affiche les info d'un gardien*/
+/*static*/ void affiche_info_gardien(Gardien *g);
+
+void affiche_info_gardien(Gardien *g){
+    assert(NULL != g);
+
+    if(NULL == g){
+        fprintf(stderr, "Gardien NULL");
+        return;
+    }
+    switch(g->alerte){
+        case MODE_NORMAL : printf("Mode : Mode normal\n"); break;
+        case MODE_PANIQUE : printf("Mode : Mode panique\n"); break;
+        default : printf("MODE INCORRECT\n"); break;
+    }
+    switch(g->detecte){
+        case JOUEUR_NON_DETECTE : printf("Etat de detection : Joueur non detecté\n"); break;
+        case JOUEUR_DETECTE : printf("Etat de detection : Joueur dectecté\n"); break;
+        default : printf("ETAT INCORRECT\n"); break;
+    }
+    switch(g->direction){
+        case HAUT : printf("Direction : HAUT\n"); break;
+        case BAS : printf("Direction : BAS\n"); break;
+        case GAUCHE : printf("Direction : GAUCHE\n"); break;
+        case DROITE : printf("Direction : DROITE\n"); break;
+        default : printf("DIRECTION INCORRECT\n"); break;
+    }
+    printf("rayon detection : %d\n", g->distance_detection);
+    printf("Position [x][y] : [%f][%f]\n", g->pos.x, g->pos.y);
+    printf("Vitesse : %f\n", g->vitesse);
+    printf("Nombre d'entrée en mode panique : %d\n", g->cpt_panique);
+}
diff --git a/src/Gestion_terrain.c b/src/Gestion_terrain.c
new file mode 100644
index 0000000..2852c94
--- /dev/null
+++ b/src/Gestion_terrain.c
@@ -0,0 +1,67 @@
+#include "../include/Gestion_terrain.h"
+
+
+/*massi*/
+/*
+Interaction joueur / relique (tu vas prendre ma reponse de cllsion )
+interaction gardien / joueur  (tu vas prendre ma reponse de cllsion )
+interaction gardien/gardien (tu vas prendre ma reponse de cllsion )
+interaction gardien/mur (tu vas prendre ma reponse de cllsion )
+interaction joueur/mur (tu vas prendre ma reponse de cllsion )
+avancement des pions  (tu vas prendre ma reponse de cllsion )
+---> regard du gardien en temps réel
+
+gestion fin de jeu --> si tte les relique (fin game)
+retour tuile uen fois usé par joeuru. --> tuile_case
+
+tuile se vide si joueur recup -- puis recharge si mana depensé(collision )
+
+*/
+
+/*Fonction qui renvoie 1 si le joueur est dans la relique ou 0 sinon.*/
+int interaction_joueur_relique(Plateau *p){
+    int i;
+    assert(NULL != p);
+    for(i = 0; i < NB_RELIQUE; ++i){
+        if(est_dans_relique(&(p->joueur), &(p->relique[i])) && p->relique[i].etat == NON_RECUPERER){
+            change_etat_obj(&(p->relique[i].etat));
+            p->joueur.nb_relique++;
+            return 1;
+        }
+    }
+    return 0;
+}
+
+
+int interaction_joueur_tuile(Plateau *p){
+    int i;
+    assert(NULL != p);
+    for(i = 0; i < NB_TUILE; ++i){
+        if(est_dans_tuile(&(p->joueur), &(p->tuile[i])) && p->tuile[i].etat == NON_RECUPERER){
+            change_etat_obj(&(p->tuile[i].etat));
+            p->joueur.mana += p->tuile[i].mana;
+            return 1;
+        }
+    }
+    return 0;
+}
+
+
+void interaction_gardien_gardien(){
+    return ;
+}
+
+/*interaction_joueur_mur ==> a gerer dans les deplacment du joueur*/
+void deplacement_joueur(Plateau *p){
+    assert(NULL != p);
+    return ;
+}
+
+int fin_de_jeu(Joueur const *j){
+    if(j->pos.x == COORD_FIN_DE_JEU_X &&
+        j->pos.y == COORD_FIN_DE_JEU_Y &&
+        j->nb_relique == NB_RELIQUE){
+            return 1;
+        }
+    return 0;
+}
diff --git a/src/Joueur.c b/src/Joueur.c
new file mode 100644
index 0000000..33c2a9e
--- /dev/null
+++ b/src/Joueur.c
@@ -0,0 +1,108 @@
+#include "../include/Joueur.h"
+
+/*s'occupe de changer la vitesse selon le mode*/
+static void change_vitesse_joueur(Mode_joueur *mode, float *vitesse){
+    if(*mode == MODE_ACCELERE && *vitesse < 1.2){
+        *vitesse += INCREMENTE_VITESSE_JOUEUR;
+        if(*vitesse > 1.2){
+            *vitesse = 1.2;
+        }
+    }
+    else if(*vitesse < 0.9){
+            *vitesse += INCREMENTE_VITESSE_JOUEUR;
+            if(*vitesse > 0.9){
+                *vitesse = 0.9;
+            }
+    }
+}
+
+/*augmente la vitesse d'un joueur */
+void augmente_vitesse_joueur(Mode_joueur *mode, float *vitesse){
+    switch(*mode){
+        case AUCUN_MODE :  change_vitesse_joueur(mode, vitesse);
+                            break;
+        case MODE_INVISIBLE :   change_vitesse_joueur(mode, vitesse);
+                                break;
+        case MODE_ACCELERE :    change_vitesse_joueur(mode, vitesse);
+                                break;
+        default : printf("Mode incorrect\n"); *vitesse = 0; break;
+    }
+}
+
+void config_joueur_mode_normal(Joueur *j){
+    j->mode = AUCUN_MODE;
+    j->direction = -1;
+    j->nb_relique = 0;
+    j->mana = 0;
+    j->pos.x = j->pos.y = 2;
+    j->vitesse = VITESSE_JOUEUR_BASE;
+}
+
+void initialise_joueur(Joueur *j){
+    assert(NULL != j);
+    if(NULL == j){
+        fprintf(stderr, "Le joueur est NULL !\n");
+        return;
+    }
+    config_joueur_mode_normal(j);
+}
+
+
+
+/*static*/ void affiche_info_joueur(Joueur const *j){
+    assert(NULL != j);
+    if(NULL == j){
+        fprintf(stderr, "Le joueur est NULL !\n");
+        return;
+    }
+    puts("");
+    switch(j->mode){
+        case AUCUN_MODE : printf("mode :MODE NORMAL\n"); break;
+        case MODE_INVISIBLE :  printf("mode :MODE INVISIBLE\n"); break;
+        case MODE_ACCELERE : printf("mode :MODE ACCELERE\n"); break;
+        default : printf("Mode incorrect\n"); break;
+    }
+    printf("nombre de relique : %d\n", j->nb_relique);
+    printf("nb de mana : %d %c\n", j->mana, '%');
+    printf("position [x][y] : [%f][%f]\n", j->pos.x, j->pos.y);
+    printf("direction -1 à l'initial : %d\n", j->direction);
+    printf("Vitesse : %.2f\n", j->vitesse);
+}
+
+
+/*Fonction qui s'occupe de gerer les deplacements d'un joueur*/
+/*
+int deplacements_joueur(Joueur *j, char *touche){
+    assert(NULL != j);
+    switch(*touche){
+        case 'z' : change_direction_joueur(j, HAUT); return 1;break;
+        case 'q' : change_direction_joueur(j, BAS); return 1;break;
+        case 's' : change_direction_joueur(j, GAUCHE); return 1;break;
+        case 'd' : change_direction_joueur(j, DROITE); return 1;break;
+        default : printf("ON FAIT RIEN - 1\n"); break;
+    }
+    return 0;
+}*/
+
+
+/*
+Initialisation joueur
+sa vitesse de base / case actuelle/ direction / pouvoir (jauge de mana) /
+activation de pvr
+recolte mana
+touche avancement
+
+lien avec gestion de terrain pour retour_tuile
+
+Compteur de mana depensé (++à)
+
+gestion direction
+*/
+
+/*
+0 : case vide
+1 : mur
+2 : gardien
+3 : relique
+4 : joueur
+*/
diff --git a/src/Moteur_de_jeu.c b/src/Moteur_de_jeu.c
new file mode 100644
index 0000000..ee28eea
--- /dev/null
+++ b/src/Moteur_de_jeu.c
@@ -0,0 +1,393 @@
+#include "../include/Moteur_de_jeu.h"
+
+
+/*Prashath*/
+/*
+generation tuile init tuile
+generation de relique(quand je pose je verifie la distance euclidienne  avec le joueur >= 20) )
+generation dujoueur (verifier la case sinon regenere)
+generation gardien (quand je pose je verifie la distance euclidienne  avec le joueur >= 20)
+verification de l emplacement correcte
+
+
+Crée chrono au lancement du jeu ->>> + temps de joueur à finir
+*/
+
+/*
+void init_coord_aleatoire(Position *pos){
+    int x, y;
+
+    do{
+        x = 4 + rand() % (10 - 4);
+        y = 4 + rand() % (10 - 4);
+    }while(est_dans_mur(&x, &y));
+
+    pos->x = x;
+    pos->y = y;
+}
+
+*/
+
+static void make_wall_on_board(int i,int j ,int nb,int direction ,Plateau * game){
+    /*printf("Poser a la position x %d et y %d avec un nb de %d\n",i,j,nb);*/
+    int cpt;
+    if(nb==0){
+        return;
+    }
+    if(direction ==0){
+        for(cpt=1;cpt<nb+1;cpt++){
+            game->plateau[i][j+cpt]=1;
+        }
+    }
+    if(direction ==1){
+        for(cpt=1;cpt<nb+1;cpt++){
+            game->plateau[i][j-cpt]=1;
+        }
+    }
+    if(direction ==2){
+        for(cpt=1;cpt<nb+1;cpt++){
+            game->plateau[i+cpt][j]=1;
+        }
+    }
+    if(direction ==3){
+        for(cpt=1;cpt<nb+1;cpt++){
+            game->plateau[i-cpt][j]=1;
+        }
+    }
+}
+
+static int verification_case(int i ,int j ,Plateau game,int direction ){
+    int x,y;
+    if(i>8 && direction !=3 &&direction !=2){
+        for(x =1;x<minside;x++){
+            if(game.plateau[i-x][j]==1){
+           /*printf(" i = %d j = %d direction = %d 1\n",i,j,direction);*/return 0;}
+        }
+
+    }
+    if(i<LARGEUR_PLATEAU-10 && direction !=2&&direction !=3){
+        for ( y = 1; y < minside; y++){
+            if(game.plateau[i+y][j]==1){
+            /*printf(" i = %d j = %d direction = %d 2\n",i,j,direction);*/return 0;}
+        }
+    }
+    if(j<LONGEUR_PLATEAU-10 && direction !=0 && direction !=1 ){
+        for(x =1 ;x<minside;x++){
+            if(game.plateau[i][j+x]==1){/*printf("i = %d j = %d direction = %d 3\n",i,j,direction);*/return 0;}
+        }
+    }
+    if(j>8 && direction !=1 && direction !=0){
+        for(y =1;y< minside;y++){
+            if(game.plateau[i][j-y]==1){/*printf(" i = %d j = %d direction = %d 4\n",i,j,direction);*/return 0;}
+        }
+    }
+    return 1;
+
+}
+
+
+static int lenght_of_wall_verification(int x,int y,Plateau game,int direction){
+    int i, j, cpt = 0;
+   /*printf("lenght_of_wall_verification x = %d y = %d direction =%d \n",x,y,direction);*/
+    if(direction == 0 && y < LONGEUR_PLATEAU - 1){
+        for(j = y + 1; j < LONGEUR_PLATEAU; ++j){
+            if(game.plateau[x][j]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
+            if(verification_case(x, j, game, direction) == 0){/*printf("lenght_of_wall_verification return 0\n");*/return 0;}
+            ++cpt;
+        }
+    }
+    else if(direction == 1 && y > 0){
+        for(j = y - 1; j >= 0; --j){
+            if(game.plateau[x][j] == 1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
+            if(verification_case(x, j, game, direction) == 0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+            ++cpt;
+        }
+    }
+    else if(direction == 3 && x > 0){
+        for ( i = x-1; i>=0; i--){
+           if(game.plateau[i][y]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
+            if(verification_case(i,y,game,direction)==0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+            cpt++;
+        }
+    }
+    else if(direction == 2 && x < LARGEUR_PLATEAU-1){
+        for ( i = x+1; i<LARGEUR_PLATEAU; i++){
+            if(game.plateau[i][y]==1){/*printf("lenght_of_wall_verification return %d \n",cpt);*/return cpt;}
+            if(verification_case(i,y,game,direction)==0){/*printf("lenght_of_wall_verification return 0 \n");*/return 0;}
+            cpt++;
+        }
+    }
+    /*printf("return 0\n");*/
+    return 0;
+
+}
+
+static int line_of_wall_respected(int x ,int y ,Plateau game,int direction){
+    int i,j,cpt=0;
+    /*printf(" line_of_wall_respected avec x %d et y %d et direction %d \n",x,y,direction);*/
+    if((direction == 0 || direction ==1)){
+        if((direction==0&& y>LONGEUR_PLATEAU-1) ||(direction==1&& y<1)){/*printf("line_of_wall_respected return 1 \n");*/return 0;}
+        for(i = x ; i<LARGEUR_PLATEAU;i++){
+            if(direction == 0 && game.plateau[i][y+1]==1){ /*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside +1 ? 1:0;}
+            if(direction == 1  && game.plateau[i][y-1]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
+            cpt++;
+        }
+    }
+    if((direction == 2 || direction ==3)){
+        if((direction ==2 && x > LARGEUR_PLATEAU-1)||(direction ==3 && x < 1)){/*printf("line_of_wall_respected return 0\n");*/return 0;}
+        for(j = y;j<LONGEUR_PLATEAU;j++){
+            if(direction ==2 && game.plateau[x+1][j]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
+            if(direction==3 && game.plateau[x-1][j]==1){/*printf("line_of_wall_respected return %d \n",cpt);*/return cpt>= minside+1 ? 1:0;}
+            cpt++;
+        }
+    }
+    /*printf("line_of_wall_respected return %d \n",cpt);*/
+    return cpt>= minside ? 1:0;
+}
+
+
+static void generation_wall_on_game_by_line(double line,int direction,int nb,Plateau * game){
+    /*printf("nb = %d \n",nb);*/
+    int i,j,cpt;
+    if(direction ==0|| direction==1){
+        for ( j = 0; j < LONGEUR_PLATEAU; j++){
+            for ( i = 0; i < LARGEUR_PLATEAU; i++){
+                if(game->plateau[i][j]==1){cpt++;}
+                if (game->plateau[i][j]==0){cpt=0;}
+                /*if(line_of_wall_respected(i,j,(*game),direction)==-1){break;}*/
+                if(cpt>=(int)line && line_of_wall_respected(i,j,(*game),direction)==1 ){
+                    /*printf("Le cpt de la fonction principale = %d \n",cpt);*/
+                    /*printf("On rentre dans la verification pricipale\n");*/
+                    if(lenght_of_wall_verification(i,j,(*game),direction)>6){
+                        printf(" accepte avec i = %d et j = %d \n",i,j);
+                        if (rand()%(nb)==0){
+                           printf(" rand   accepte\n");
+                            make_wall_on_board(i,j,lenght_of_wall_verification(i,j,(*game),direction)-3,direction,game);
+                            return ;
+                        }
+                    }
+                }
+            }
+        }
+    }
+    if(direction ==2|| direction==3){
+        for ( i = 0; i < LARGEUR_PLATEAU; i++){
+            for ( j = 0; j< LONGEUR_PLATEAU; j++){
+                if(game->plateau[i][j]==1){cpt++;}
+                if (game->plateau[i][j]==0){ cpt=0;}
+                /*if(line_of_wall_respected(i,j,(*game),direction)==-1){break;}*/
+                if(cpt>=(int)line && line_of_wall_respected(i,j,(*game),direction)==1 ){
+                    /*printf("Le cpt de la fonction principale = %d \n",cpt);*/
+                    /*printf("On rentre dans la verification pricipale\n");*/
+                    if(lenght_of_wall_verification(i,j,(*game),direction)>6){
+                        printf(" accepte avec i = %d et j = %d \n",i,j);
+
+                        if (rand()%(nb)==0){
+                            printf(" rand   accepte\n");
+                            make_wall_on_board(i,j,lenght_of_wall_verification(i,j,(*game),direction)-3,direction,game);
+                            return ;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
+
+static void generation_lenght_wall(double height,double lenght,int nb ,Plateau *game){
+    double x, y, line;
+    int mur;
+    x = height < lenght ? lenght : height;
+    y = height < lenght ? height : lenght;
+    if(x < (2 * minside + 1)){return ;}
+    if(x < (4 * minside)){
+        if(rand() % 2 == 0){return ;}
+    }
+    line = x / 2;
+    mur = rand() % 4 ;/* 0 droite, 1 gauche , 2 bas ,3 haut*/
+    printf("direction mur %d, distance: %f\n", mur, line);
+    generation_wall_on_game_by_line(line, mur, nb, game);
+    generation_lenght_wall(line, y, nb + 2, game);
+    generation_lenght_wall(line, y, nb + 2, game);
+}
+
+
+static void generation_wall_ext(Plateau *game){
+    int i,j;
+    for (i= 0; i < LARGEUR_PLATEAU; i++)
+    {
+        for(j =0;j<LONGEUR_PLATEAU;j++){
+            if(i == 0 || i ==44||j == 0 || j == 59){
+                game->plateau[i][j] = 1;
+            }
+            else{
+                game->plateau[i][j] = 0;
+            }
+        }
+    }
+
+
+}
+
+
+
+static int not_on_openside(int x,int y , Plateau game){
+    int i ,hor=0,vertic=0;
+    for(i=1;i<=3;i++){
+        if(game.plateau[x-i][y]==1){
+            hor+=1;
+            break;
+        }
+    }
+    for(i=1;i<=3;i++){
+        if(game.plateau[x+i][y]==1){
+            hor+=1;
+            break;
+        }
+    }
+    if(hor==2){return 0;}
+    for(i=1;i<=3;i++){
+        if(game.plateau[x][y-i]==1){
+            vertic+=1;
+            break;
+        }
+    }
+     for(i=1;i<=3;i++){
+        if(game.plateau[x][y+i]==1){
+            vertic+=1;
+            break;
+        }
+    }
+    if(vertic==2){return 0;}
+    return 1;
+
+}
+static int position_verification(int x,int y ,Plateau game){
+    if(game.plateau[x][y] == 0 && sqrt((1-x)*(1-x)+(1-y)*(1-y)) >= 20 && not_on_openside(x,y,game)==1){
+        return 1;
+    }
+    return 0;
+}
+static void init_Gardien(Plateau * game){
+    int i,x,y;
+    for ( i = 0; i < NB_GARDIEN; i++)
+    {
+        initalise_gardien(&game->gardien[i]);
+        while(1){
+            x = rand()%57+1;
+            y=rand()%42+1;
+            if(position_verification(x,y,*game)==1){
+                game->gardien[i].pos.x = x;
+                game->gardien[i].pos.y = y;
+                break;
+            }
+        }
+    }
+
+}
+
+static void init_Relique(Plateau * game){
+    int i,x,y;
+    for(i=0;i<NB_RELIQUE;i++){
+        initialise_relique(&game->relique[i]);
+        while(1){
+            x = rand()%57+1;
+            y=rand()%42+1;
+            if(position_verification(x,y,*game)==1){
+                game->relique[i].pos.x = x;
+                game->relique[i].pos.y = y;
+                break;
+            }
+        }
+    }
+}
+
+static void init_tuile(Plateau * game){
+
+    int i ,x,y;
+    for(i=0;i<NB_TUILE;i++){
+        game->tuile[i].mana = 60;
+        game->tuile[i].etat = NON_RECUPERER;
+        while(1){
+            x = rand()%57+1;
+            y=rand()%42+1;
+            if(position_verification(x,y,*game)==1){
+                game->tuile[i].pos.x = x;
+                game->tuile[i].pos.y = y;
+                break;
+            }
+        }
+    }
+}
+
+static void init_plateau(Plateau *p){
+    int i, j;
+    for(i = 0; i < LARGEUR_PLATEAU; ++i){
+        for(j = 0; j < LONGEUR_PLATEAU; ++j){
+            p->plateau[i][j] = 0;
+        }
+    }
+}
+
+
+static void init_objects_in_map(Plateau * game){
+    int i ;
+    initialise_joueur(&game->joueur);
+    printf(" x = %.0f \n",game->joueur.pos.x);
+    init_Gardien(game);
+    init_Relique(game);
+    init_tuile(game);
+    game->plateau[(int)game->joueur.pos.x][(int)game->joueur.pos.y] = 4;
+    for(i = 0;i<NB_GARDIEN;i++){
+        game->plateau[(int)game->gardien[i].pos.x][(int)game->gardien[i].pos.y] =2;
+        printf("poser gardien %.0f %.0f \n",game->gardien[i].pos.x,game->gardien[i].pos.y);
+
+
+    }
+    for(i = 0;i<NB_RELIQUE;i++){
+        game->plateau[game->relique[i].pos.x][game->relique[i].pos.y]=3;
+        printf("poser relique\n");
+
+    }
+    for(i = 0;i<NB_TUILE;i++){
+        game->plateau[game->tuile[i].pos.x][game->tuile[i].pos.y]=5;
+        printf("poser tuile\n");
+    }
+
+}
+static void generation_wall_ext_print(Plateau game){
+    int i,j;
+    for (i= 0; i < LARGEUR_PLATEAU; i++)
+    {
+        for(j =0;j<LONGEUR_PLATEAU;j++){
+            printf("%d ",game.plateau[i][j]);
+        }
+        printf("\n");
+    }
+
+
+}
+
+void create_map(Plateau *game){
+    init_plateau(game);
+    generation_wall_ext(game);
+    generation_lenght_wall(58.0,43.0,1,game);
+    printf(" Le plateau de jeu apres : \n");
+    /*generation_wall_ext_print(*game);*/
+    printf(" Le plateau de jeu apres  object : \n");
+    init_objects_in_map(game);
+    /*generation_wall_ext_print(*game);*/
+}
+
+
+/*Change l'etat d'un objet ou d'une relique*/
+void change_etat_obj(Etat_objet *o){
+    assert(NULL != o);
+
+    switch(*o){
+        case NON_RECUPERER : *o = RECUPERER; break;
+        case RECUPERER : *o = NON_RECUPERER; break;
+        default : printf("ETAT INCORRECT !\n"); break;
+    }
+}
diff --git a/src/Moteur_graphique.c b/src/Moteur_graphique.c
new file mode 100644
index 0000000..a0cc693
--- /dev/null
+++ b/src/Moteur_graphique.c
@@ -0,0 +1,134 @@
+#include "../include/Moteur_graphique.h"
+#include "MLV/MLV_all.h"
+
+/*Prashath*/
+/*
+Affichage des obj possible (gardien, pion, relique, joueur, plateau de jeu, mur, tuile)
+affichage du menu
+
+FRAME --> a reglé 1/60
+*/
+
+static void dessine_quadrillage(int longueur, int largeur){
+    int i;
+    for(i = 0; i <= largeur; i += TAILLE_CASE){
+        MLV_draw_filled_rectangle(0, i, longueur, 0, MLV_COLOR_BLACK);
+    }
+    for(i = 0; i <= longueur; i += TAILLE_CASE){
+        MLV_draw_filled_rectangle(i, 0, 0, largeur, MLV_COLOR_BLACK);
+    }
+    printf("q-OK\n");
+}
+
+static void dessine_mur(int *x, int *y, int taille_mur){
+    MLV_draw_filled_rectangle(*x, *y, taille_mur, taille_mur, MLV_COLOR_BLACK);
+}
+
+static void dessine_gardien(Plateau const *p){
+    int i;
+    for(i = 0; i < NB_GARDIEN; ++i){
+        switch(p->gardien[i].alerte){
+            case MODE_NORMAL : MLV_draw_filled_circle(p->gardien[i].pos.x * TAILLE_CASE,
+                                                        p->gardien[i].pos.y * TAILLE_CASE,
+                                                         TAILLE_CASE / 2, MLV_COLOR_BLUE);
+                               MLV_draw_circle(p->gardien[i].pos.x * TAILLE_CASE,
+                                                p->gardien[i].pos.y * TAILLE_CASE,
+                                                 TAILLE_CASE * p->gardien[i].distance_detection,
+                                                  MLV_COLOR_BLUE);
+                               break;
+            case MODE_PANIQUE : MLV_draw_filled_circle(p->gardien[i].pos.x * TAILLE_CASE,
+                                                        p->gardien[i].pos.y * TAILLE_CASE,
+                                                         TAILLE_CASE / 2, MLV_COLOR_GREEN);
+                                MLV_draw_circle(p->gardien[i].pos.x * TAILLE_CASE,
+                                                 p->gardien[i].pos.y * TAILLE_CASE,
+                                                  TAILLE_CASE * p->gardien[i].distance_detection,
+                                                   MLV_COLOR_BLUE);
+                                break;
+
+            default : break;
+        }
+
+    }
+}
+
+static void dessine_relique(Plateau const *p){
+    int i;
+    for(i = 0; i < NB_RELIQUE; ++i){
+        switch(p->relique[i].etat){
+            case NON_RECUPERER : MLV_draw_filled_circle(p->relique[i].pos.x * TAILLE_CASE,
+                                                        p->relique[i].pos.y * TAILLE_CASE,
+                                                         TAILLE_CASE / 2, MLV_COLOR_LIGHT_BLUE);
+                               break;
+            case RECUPERER : MLV_draw_filled_circle(p->relique[i].pos.x * TAILLE_CASE,
+                                                        p->relique[i].pos.y * TAILLE_CASE,
+                                                         TAILLE_CASE / 2, MLV_COLOR_PURPLE);
+                                break;
+
+            default : break;
+        }
+
+    }
+}
+
+static void dessine_tuile(Plateau const *p){
+    int i;
+    for(i = 0; i < NB_TUILE; ++i){
+        switch(p->tuile[i].etat){
+            case NON_RECUPERER : MLV_draw_filled_circle(p->tuile[i].pos.x * TAILLE_CASE,
+                                                        p->tuile[i].pos.y * TAILLE_CASE,
+                                                         TAILLE_CASE / 2, MLV_COLOR_ORANGE);
+                               break;
+            case RECUPERER : MLV_draw_filled_circle(p->tuile[i].pos.x * TAILLE_CASE,
+                                                        p->tuile[i].pos.y * TAILLE_CASE,
+                                                         TAILLE_CASE / 2, MLV_COLOR_PURPLE);
+                                break;
+
+            default : break;
+        }
+
+    }
+}
+
+
+static void dessine_joueur(Joueur const *joueur){
+    switch(joueur->mode){
+        case AUCUN_MODE : MLV_draw_filled_circle(joueur->pos.x * TAILLE_CASE,
+                                                    joueur->pos.y * TAILLE_CASE,
+                                                     TAILLE_CASE / 2, MLV_COLOR_RED);
+                          break;
+        case MODE_INVISIBLE : MLV_draw_filled_circle(joueur->pos.x * TAILLE_CASE,
+                                                      joueur->pos.y * TAILLE_CASE,
+                                                       TAILLE_CASE / 2, MLV_COLOR_WHITE);
+                              break;
+        case MODE_ACCELERE : MLV_draw_filled_circle(joueur->pos.x * TAILLE_CASE,
+                                                     joueur->pos.y * TAILLE_CASE,
+                                                      TAILLE_CASE / 2, MLV_COLOR_PINK);
+                             break;
+        default : break;
+    }
+}
+
+
+
+void dessine_plateau_graphique(Plateau const *p, int longueur, int largeur){
+    int i, j, case_x, case_y;
+    MLV_clear_window(MLV_COLOR_GREY40);
+    dessine_quadrillage(longueur * TAILLE_CASE, largeur * TAILLE_CASE);
+
+    for(i = 0; i < largeur; ++i){
+        case_y = i * TAILLE_CASE;
+        for(j = 0; j < longueur; ++j){
+            case_x = j * TAILLE_CASE;
+            /*printf("%d : %d __ %d : %d\n", i, case_y, j, case_x);*/
+            switch(p->plateau[i][j]){
+                case 1 : dessine_mur(&case_x, &case_y, TAILLE_CASE); break;
+                case 4 : dessine_joueur(&(p->joueur)); break;
+                default : break;
+            }
+        }
+    }
+    dessine_gardien(p);
+    dessine_relique(p);
+    dessine_tuile(p);
+    MLV_actualise_window();
+}
diff --git a/src/Relique.c b/src/Relique.c
new file mode 100644
index 0000000..dcf627c
--- /dev/null
+++ b/src/Relique.c
@@ -0,0 +1,36 @@
+#include "../include/Relique.h"
+
+
+/*massi*/
+
+/*Initialise une relique*/
+void initialise_relique(Relique *r){
+    assert(NULL != r);
+
+    r->etat = NON_RECUPERER;
+}
+
+
+/*affiche TEMPORAIRE*/
+/*static*/ void affiche_info_relique(Relique const *r);
+
+/*
+int main(){
+    Relique relique;
+    srand(time(NULL));
+    initialise_relique(&relique);
+    affiche_info_relique(&relique);
+
+    return 0;
+}
+*/
+
+void affiche_info_relique(Relique const *r){
+    assert(NULL != r);
+    switch(r->etat){
+        case NON_RECUPERER : printf("NON RECUPERER\n"); break;
+        case RECUPERER : printf("RECUPERER\n"); break;
+        default : printf("ETAT INCORRECT !\n"); break;
+    }
+    printf("Position [x][y] : [%d][%d]\n", r->pos.x, r->pos.y);
+}
diff --git a/src/main.c b/src/main.c
new file mode 100644
index 0000000..3c121d5
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,170 @@
+#define _GNU_SOURCE
+#define _POSIX_C_SOURCE 1999309L
+/*Uniquement car on utilise clock_gettime, car ce ,'est pas ansi C89'*/
+
+#include "../include/Gestion_terrain.h"
+#include "../include/Moteur_graphique.h"
+#include "MLV/MLV_all.h"
+
+static void aff_plat(Plateau *plat){
+    int i, j;
+    printf("\n\n");
+    for(i = 0; i < LARGEUR_PLATEAU; ++i){
+        for(j = 0; j < LONGEUR_PLATEAU; ++j){
+            if(plat->plateau[i][j] == 0){
+                printf("  ");
+            }
+            else{
+                printf("%d ", plat->plateau[i][j]);
+            }
+
+        }
+        printf("\n");
+    }
+    printf("\n\n");
+}
+
+/*Ancienne version */
+/*
+if(MLV_get_keyboard_state(MLV_KEYBOARD_z) == MLV_PRESSED){
+    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
+    plateau.joueur.pos.y -= plateau.joueur.vitesse; printf("P-HAUT ");
+}
+else if(MLV_get_keyboard_state(MLV_KEYBOARD_s) == MLV_PRESSED){
+    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
+    plateau.joueur.pos.y += plateau.joueur.vitesse; printf("P-BAS ");
+}
+else if(MLV_get_keyboard_state(MLV_KEYBOARD_q) == MLV_PRESSED){
+    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
+    plateau.joueur.pos.x -= plateau.joueur.vitesse; printf("P-GAUCHE ");
+}
+else if(MLV_get_keyboard_state(MLV_KEYBOARD_d) == MLV_PRESSED){
+    augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
+    plateau.joueur.pos.x += plateau.joueur.vitesse; printf("P-DROITE ");
+}
+else{
+    plateau.joueur.vitesse = 0;
+}
+*/
+
+
+int main(int argc, const char * const argv[]){
+    Plateau plateau;
+    struct timespec new_time, end_time;
+    double frametime, extratime;
+    struct timespec start, end;
+    MLV_Keyboard_modifier mod;
+    MLV_Keyboard_button sym;
+    MLV_Button_state state;
+    MLV_Event event;
+
+    MLV_create_window("ko", "ka", LONGUEUR_FENETRE, LARGEUR_FENETRE);
+    create_map(&plateau);
+    /*aff_plat(&plateau);
+    */
+    srand(time(NULL));
+    clock_gettime(CLOCK_REALTIME, &start);
+    plateau.joueur.direction = HAUT;
+    printf("H->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
+    plateau.joueur.direction = BAS;
+    printf("B->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
+    plateau.joueur.direction = GAUCHE;
+    printf("G->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
+    plateau.joueur.direction = DROITE;
+    printf("D->%d\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));
+    while(1){
+        /*CALCUL_DE_TEMPS*/
+        clock_gettime(CLOCK_REALTIME, &end_time);
+        dessine_plateau_graphique(&plateau, LONGEUR_PLATEAU, LARGEUR_PLATEAU);
+
+        event = MLV_get_event(&sym, &mod, NULL, NULL, NULL, NULL, NULL, NULL, &state);
+        printf("state %d: \n", state);
+
+        if(sym == MLV_KEYBOARD_z && state == MLV_PRESSED){
+            plateau.joueur.direction = HAUT;
+            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
+            }
+            else{
+                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
+                plateau.joueur.pos.y -= plateau.joueur.vitesse; printf("P-HAUT ");
+            }
+        }
+        else if(sym == MLV_KEYBOARD_s && state == MLV_PRESSED){
+            plateau.joueur.direction = BAS;
+            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
+            }
+            else{
+                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
+                plateau.joueur.pos.y += plateau.joueur.vitesse; printf("P-BAS ");
+            }
+
+        }
+        else if(sym == MLV_KEYBOARD_q && state == MLV_PRESSED){
+            plateau.joueur.direction = GAUCHE;
+            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
+            }
+            else{
+                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
+                plateau.joueur.pos.x -= plateau.joueur.vitesse; printf("P-GAUCHE ");
+            }
+        }
+        else if(sym == MLV_KEYBOARD_d && state == MLV_PRESSED){
+            plateau.joueur.direction = DROITE;
+            if(collision_contre_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction), &(plateau.joueur.vitesse)) == 1){
+            }
+            else{
+                augmente_vitesse_joueur(&(plateau.joueur.mode), &(plateau.joueur.vitesse));
+                plateau.joueur.pos.x += plateau.joueur.vitesse; printf("P-DROITE ");
+            }
+        }
+        else{
+            plateau.joueur.vitesse = 0;
+        }
+        switch(plateau.joueur.direction){
+            case HAUT :printf("H : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
+            case BAS :printf("B : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
+            case DROITE:printf("D : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
+            case GAUCHE:printf("G : %d\n\n", distance_vers_mur(&plateau, &(plateau.joueur.pos), &(plateau.joueur.direction)));break;
+            default :break;
+        }
+
+        printf("vitesse:%f \n", plateau.joueur.vitesse);
+        if(event == MLV_KEY){
+            /*if(sym == MLV_KEYBOARD_z && state == MLV_PRESSED){
+                plateau.joueur.pos.y -= 1; printf("P-HAUT ");
+            }
+            else if(sym == MLV_KEYBOARD_s && state == MLV_PRESSED){
+                plateau.joueur.pos.y += 1; printf("P-BAS ");
+            }
+            else if(sym == MLV_KEYBOARD_q && state == MLV_PRESSED){
+                plateau.joueur.pos.x -= 1; printf("P-GAUCHE ");
+            }
+            else if(sym == MLV_KEYBOARD_d && state == MLV_PRESSED){
+                plateau.joueur.pos.x += 1; printf("P-DROITE ");
+            }*/
+            if(sym == MLV_KEYBOARD_t){
+                aff_plat(&plateau);
+                sleep(2);
+                break;
+            }
+        }
+
+        /*Mecanisme de jeu et tt*/
+        /* ... */
+        clock_gettime(CLOCK_REALTIME, &new_time);
+        frametime = new_time.tv_sec - end_time.tv_sec;
+        frametime += (new_time.tv_sec - end_time.tv_sec) / 1.0E9;
+        extratime = (1.0 / 60) - frametime;
+        printf("(1.0/60.0) = %f\nextratime : %f\nframetime : %f\n",(1.0 / 60.0), extratime, frametime);
+
+        if(extratime > 0){
+            MLV_wait_milliseconds((int)(extratime * 1000));
+        }
+    }
+    clock_gettime(CLOCK_REALTIME, &end);
+    /*Chrono rapide du joueur - a ameliorer eventuellement ==> */
+    printf("Durée de la partie = %.2fs\n",(double) ((end.tv_sec - start.tv_sec) + ((end.tv_nsec - start.tv_nsec) / 1.0E9)));
+
+    MLV_free_window();
+    return 0;
+}
diff --git a/src/test b/src/test
new file mode 100755
index 0000000..71c8794
Binary files /dev/null and b/src/test differ
diff --git a/test/Projet_C.zip b/test/Projet_C.zip
new file mode 100644
index 0000000..6774993
Binary files /dev/null and b/test/Projet_C.zip differ
diff --git a/test/main b/test/main
new file mode 100755
index 0000000..f430105
Binary files /dev/null and b/test/main differ
diff --git a/test/makefile b/test/makefile
new file mode 100644
index 0000000..2c94227
--- /dev/null
+++ b/test/makefile
@@ -0,0 +1,24 @@
+CC = gcc
+CFLAGS = -ansi -Wall -Werror -pedantic
+LDFLAGS = -lMLV
+OBJ = obj/main.o obj/Menu.o obj/Terrain.o obj/Define.o
+TARGET = main
+SRC = src
+HEADER = src/header
+
+all: $(TARGET)
+
+$(TARGET): $(OBJ)
+	$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)
+
+obj/main.o: $(SRC)/main.c $(HEADER)/Menu.h $(HEADER)/Terrain.h
+	$(CC) -c $< -o obj/main.o $(CFLAGS)
+obj/Define.o: $(SRC)/Define.c $(HEADER)/Define.h
+		$(CC) -c $< -o obj/Define.o $(CFLAGS)
+obj/Menu.o: $(SRC)/Menu.c $(HEADER)/Menu.h $(HEADER)/Define.h $(HEADER)/Terrain.h
+	$(CC) -c $< -o obj/Menu.o $(CFLAGS)
+obj/Terrain.o: $(SRC)/Terrain.c $(HEADER)/Terrain.h $(HEADER)/Define.h
+	$(CC) -c $< -o obj/Terrain.o $(CFLAGS)
+
+clean:
+	rm -f $(OBJ) $(TARGET)
diff --git a/test/obj/Define.o b/test/obj/Define.o
new file mode 100644
index 0000000..06b9139
Binary files /dev/null and b/test/obj/Define.o differ
diff --git a/test/obj/Menu.o b/test/obj/Menu.o
new file mode 100644
index 0000000..6b36954
Binary files /dev/null and b/test/obj/Menu.o differ
diff --git a/test/obj/Terrain.o b/test/obj/Terrain.o
new file mode 100644
index 0000000..3770a4e
Binary files /dev/null and b/test/obj/Terrain.o differ
diff --git a/test/obj/main.o b/test/obj/main.o
new file mode 100644
index 0000000..65b6412
Binary files /dev/null and b/test/obj/main.o differ
diff --git a/test/src/Define.c b/test/src/Define.c
new file mode 100644
index 0000000..0e9c931
--- /dev/null
+++ b/test/src/Define.c
@@ -0,0 +1,8 @@
+#include "header/Define.h"
+/*
+ISO C forbids an empty translation unit - if we don't have a function
+is it weird !
+*/
+void voidish(void){
+    return;
+}
diff --git a/test/src/Menu.c b/test/src/Menu.c
new file mode 100644
index 0000000..8b7c509
--- /dev/null
+++ b/test/src/Menu.c
@@ -0,0 +1,121 @@
+#include <MLV/MLV_all.h>
+#include "header/Menu.h"
+/*NE PAS OUBLIER LE PETIT -lMLV EN COMPILANT !!*/
+
+/*Fonction pour afficher une case du menu*/
+void fabrique_case_menu(char *nom_case, int taille_interlinge, int type_case){
+    MLV_draw_adapted_text_box(
+        (HAUTEUR_FENETRE - strlen(nom_case) * DIFFERENCE_HAUTEUR) / 2,
+        LARGEUR_FENETRE / type_case,
+        nom_case,
+        taille_interlinge,
+        MLV_COLOR_RED, MLV_COLOR_GREEN, MLV_COLOR_BLACK,
+        MLV_TEXT_CENTER
+    );
+}
+
+void fabrique_case_retour(char *nom_case, int taille_interlinge, int largeur){
+    MLV_draw_adapted_text_box(
+        (HAUTEUR_FENETRE - strlen(nom_case) * DIFFERENCE_HAUTEUR) / 2,
+        largeur,
+        nom_case,
+        taille_interlinge,
+        MLV_COLOR_RED, MLV_COLOR_GREEN, MLV_COLOR_BLACK,
+        MLV_TEXT_CENTER
+    );
+}
+
+void affiche_case_menu(char *nom_case_1, char *nom_case_2, int taille_interlinge, int type_case_1, int type_case_2){
+    MLV_clear_window(MLV_COLOR_BLACK);
+    fabrique_case_menu(nom_case_1, taille_interlinge, type_case_1);
+    fabrique_case_menu(nom_case_2, taille_interlinge, type_case_2);
+    MLV_actualise_window();
+
+}
+
+/*temporaire*/
+
+
+void affiche_option(char *nom_case_1, char *nom_case_2, int taille_interlinge, int type_case_1, int type_case_2){
+    char *lance_jeu = "OPTION";
+    char *retour = "RETOUR";
+    int x = (HAUTEUR_FENETRE - strlen(retour) * DIFFERENCE_HAUTEUR) / 2;
+    int y = LARGEUR_FENETRE;
+    int n = 0, clic_x, clic_y;
+    Retour etat = AUTRE;
+    /*Action*/
+    puts("OPT");
+    MLV_clear_window(MLV_COLOR_BLACK);
+    fabrique_case_menu(lance_jeu, taille_interlinge, LARGEUR_FENETRE);
+    fabrique_case_retour(retour, taille_interlinge, LARGEUR_FENETRE - (taille_interlinge * 3 + 5));
+    MLV_actualise_window();
+    while(n == 0){
+        MLV_wait_mouse(&clic_x, &clic_y);
+        printf("x=%d y=%d\n", clic_x, clic_y);
+        printf("%d %d %ld %d\n", x, y, (x + strlen(retour) * (taille_interlinge + 3)), (y - (3 * taille_interlinge) + 5));
+        if(clic_x <= (x + strlen(retour) * (taille_interlinge + 3)) && clic_x >= x && clic_y <= y && clic_y >= (y - (4 * taille_interlinge) + 5)){
+            etat = RETOUR;
+            n = 1;
+        }
+        switch(etat){
+            case RETOUR : affiche_case_menu(nom_case_1, nom_case_2, taille_interlinge, type_case_1, type_case_2); break;
+            default : break;
+        }
+    }
+}
+
+/*fct qui affiche le menu*/
+void affiche_menu(){
+    char *lance_jeu = "Lancer Le Jeu";
+    char *option = "Option de Jeu";
+    int taille_interlinge = 10;
+    int clic_x, clic_y, x, y_jeu, y_opt;
+    int n = 0;
+    Menu etat = MENU;
+
+    x = (HAUTEUR_FENETRE - strlen(lance_jeu) * DIFFERENCE_HAUTEUR) / 2;
+    y_jeu= LARGEUR_FENETRE / LANCE_JEU;
+    y_opt = LARGEUR_FENETRE / OPTION_JEU;
+    /*Action*/
+    printf("l=%ld | o=%ld\n", strlen(lance_jeu), strlen(option));
+    /*affichage des cases pour lance et option */
+    affiche_case_menu(lance_jeu, option, taille_interlinge, LANCE_JEU, OPTION_JEU);
+    MLV_actualise_window();
+    /*Attente_clic etc pour option et lance jeu*/
+    while(n == 0){
+        etat = MENU;
+        puts("PAsse ici");
+        printf("jeu : %d %d %d %d\n", x, y_jeu, (x + taille_interlinge*(taille_interlinge + 1)), (y_jeu + (3 * taille_interlinge) + 5) );
+        printf("opt : %d %d %d %d\n", x, y_opt, (x + taille_interlinge*(taille_interlinge + 1)), (y_opt + (3 * taille_interlinge) + 5) );
+        MLV_wait_mouse(&clic_x, &clic_y);
+        printf("x=%d y=%d\n", clic_x, clic_y);
+        if(clic_x <= (x + taille_interlinge*(taille_interlinge + 1)) && clic_x >= x && clic_y >= y_jeu && clic_y <= (y_jeu + (3 * taille_interlinge) + 5)){
+            etat = JEU;
+            puts("JEU");
+            n = 1;
+        }
+        else if(clic_x <= (x + taille_interlinge*(taille_interlinge + 1)) && clic_x >= x && clic_y >= y_opt && clic_y <= (y_opt + (3 * taille_interlinge) + 5)){
+            etat = OPTION;
+            puts("OPT");
+            /*n = 1;*/
+        }
+        switch(etat){
+            case JEU : affiche_jeu(); break;
+            case OPTION : affiche_option(lance_jeu, option, taille_interlinge, LANCE_JEU, OPTION_JEU); break;
+            default : break;
+        }
+    }
+    MLV_actualise_window();
+    MLV_wait_seconds(2);
+}
+
+
+/*
+int main(void){
+    MLV_create_window("Menu", "Menu", HAUTEUR_FENETRE, LARGEUR_FENETRE);
+    //Test d'affichage du menu
+    affiche_menu();
+    MLV_free_window();
+    return 0;
+}
+*/
diff --git a/test/src/Terrain.c b/test/src/Terrain.c
new file mode 100644
index 0000000..4080c55
--- /dev/null
+++ b/test/src/Terrain.c
@@ -0,0 +1,25 @@
+#include "header/Terrain.h"
+
+
+/*Bon c'etait un prank le jeu se lance pas il faut le faire mtn*/
+void affiche_jeu(){
+    char *lance_jeu = "LA LE JEU SE LANCE TQT";
+    puts("JEU");
+    MLV_clear_window(MLV_COLOR_GREY40);
+    MLV_actualise_window();
+    MLV_draw_text(
+        (HAUTEUR_FENETRE - strlen(lance_jeu) * DIFFERENCE_HAUTEUR) / 2,
+        LARGEUR_FENETRE / DIFFERENCE_LARGEUR,
+        lance_jeu,
+        MLV_COLOR_YELLOW);
+    MLV_actualise_window();
+    MLV_wait_seconds(DELAI_ATTENTE);
+}
+
+/*http://www-igm.univ-mlv.fr/~boussica/mlv/api/French/html/MLV__color_8h_a4ebdb13aad4c58e29f9ddf8ccb953356.html#a4ebdb13aad4c58e29f9ddf8ccb953356*/
+/*
+fonction visuel à faire :
+    - dessine mur exterieur
+    - dessine grille
+    - genere mur puis dessine mur interieur
+*/
diff --git a/test/src/header/Define.h b/test/src/header/Define.h
new file mode 100644
index 0000000..1701f1f
--- /dev/null
+++ b/test/src/header/Define.h
@@ -0,0 +1,17 @@
+#ifndef __DEFINE__
+#define __DEFINE__
+
+
+#define NB_CASE_HAUTEUR 60
+#define NB_CASE_LARGEUR 45
+#define HAUTEUR_FENETRE 600
+#define LARGEUR_FENETRE 450
+#define DIFFERENCE_HAUTEUR HAUTEUR_FENETRE / NB_CASE_HAUTEUR
+#define DIFFERENCE_LARGEUR LARGEUR_FENETRE / NB_CASE_LARGEUR
+#define DELAI_ATTENTE 5
+#define LANCE_JEU 3
+#define OPTION_JEU 2
+
+void voidish(void);
+
+#endif
diff --git a/test/src/header/Menu.h b/test/src/header/Menu.h
new file mode 100644
index 0000000..aaff7e0
--- /dev/null
+++ b/test/src/header/Menu.h
@@ -0,0 +1,30 @@
+#ifndef __MENU__
+#define __MENU__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <MLV/MLV_all.h>
+#include "Terrain.h"
+/*#include "Define.h"*/
+
+typedef enum {
+    MENU,
+    JEU,
+    OPTION
+}Menu;
+
+typedef enum {
+    RETOUR,
+    AUTRE
+}Retour;
+
+void fabrique_case_menu(char *nom_case, int taille_interlinge, int type_case);
+void fabrique_case_retour(char *nom_case, int taille_interlinge, int largeur);
+void affiche_case_menu(char *nom_case_1, char *nom_case_2, int taille_interlinge, int type_case_1, int type_case_2);
+void affiche_option(char *nom_case_1, char *nom_case_2, int taille_interlinge, int type_case_1, int type_case_2);
+void affiche_menu();
+
+
+
+#endif
diff --git a/test/src/header/Terrain.h b/test/src/header/Terrain.h
new file mode 100644
index 0000000..a3990bc
--- /dev/null
+++ b/test/src/header/Terrain.h
@@ -0,0 +1,12 @@
+#ifndef __TERRAIN__
+#define __TERRAIN__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <MLV/MLV_all.h>
+#include "Define.h"
+
+void affiche_jeu();
+
+#endif
diff --git a/test/src/main.c b/test/src/main.c
new file mode 100644
index 0000000..2ef4e4e
--- /dev/null
+++ b/test/src/main.c
@@ -0,0 +1,12 @@
+#include "header/Menu.h"
+#include "header/Terrain.h"
+
+
+
+int main(void){
+    MLV_create_window("Menu", "Menu", HAUTEUR_FENETRE, LARGEUR_FENETRE);
+    /*Test d'affichage du menu*/
+    affiche_menu();
+    MLV_free_window();
+    return 0;
+}
diff --git a/test/text.txt b/test/text.txt
new file mode 100644
index 0000000..e69de29
